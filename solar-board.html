<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Solar Architect: Grid Master v4.5</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        body {
            touch-action: none;
            overflow: hidden;
            user-select: none;
        }

        canvas {
            image-rendering: pixelated;
            cursor: crosshair;
        }

        .sidebar-item {
            transition: all 0.2s;
        }

        .sidebar-item:active {
            transform: scale(0.95);
        }

        .sidebar-item.selected {
            border-color: #3b82f6;
            background-color: #eff6ff;
            box-shadow: inset 0 0 0 1px #3b82f6;
        }

        ::-webkit-scrollbar {
            width: 6px;
            height: 6px;
        }

        ::-webkit-scrollbar-track {
            background: #f1f1f1;
        }

        ::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 3px;
        }

        input[type=range] {
            -webkit-appearance: none;
            background: transparent;
        }

        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: #fbbf24;
            cursor: pointer;
            margin-top: -6px;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
        }

        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: #4b5563;
            border-radius: 2px;
        }

        .btn-disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        #height-slider::-webkit-slider-thumb {
            background: #3b82f6;
        }

        .unit-input {
            background: #eff6ff;
            border: 1px solid #bfdbfe;
            padding: 2px 4px;
            border-radius: 4px;
            width: 70px;
            text-align: right;
            font-family: monospace;
            color: #1e3a8a;
            font-size: 12px;
        }

        .layer-item {
            font-size: 11px;
            border-bottom: 1px solid #f3f4f6;
            cursor: pointer;
        }

        .layer-item:hover {
            background-color: #f9fafb;
        }

        .layer-item.active {
            background-color: #eff6ff;
            color: #1d4ed8;
            border-left: 3px solid #3b82f6;
        }

        .modal-overlay {
            background-color: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(2px);
        }
    </style>
</head>

<body class="bg-gray-900 h-screen w-screen flex flex-col text-gray-100 font-sans">

    <!-- Top Bar -->
    <div
        class="h-14 bg-gray-800 border-b border-gray-700 flex items-center justify-between px-4 shrink-0 z-20 shadow-md">
        <div class="flex items-center gap-3">
            <div class="bg-yellow-500 p-1.5 rounded text-gray-900"><i class="fa-solid fa-solar-panel text-lg"></i></div>
            <div>
                <h1 class="font-bold text-lg leading-none">Solar Architect</h1>
                <div class="text-xs text-gray-400">Grid Master v4.5</div>
            </div>
        </div>

        <!-- Location Settings -->
        <div class="flex items-center gap-2 bg-gray-700 px-3 py-1 rounded border border-gray-600">
            <i class="fa-solid fa-location-dot text-red-400 text-xs"></i>
            <div class="flex flex-col">
                <span class="text-[8px] text-gray-400 uppercase font-bold">Location</span>
                <div class="flex gap-1 items-center">
                    <input type="number" id="input-lat" value="28.6"
                        class="w-12 bg-transparent text-xs text-white font-mono border-b border-gray-500 focus:border-blue-400 outline-none"
                        placeholder="Lat" title="Latitude">
                    <input type="number" id="input-lon" value="77.2"
                        class="w-12 bg-transparent text-xs text-white font-mono border-b border-gray-500 focus:border-blue-400 outline-none"
                        placeholder="Lon" title="Longitude">
                    <button onclick="app.detectLocation()" class="text-blue-400 hover:text-blue-300 ml-1"
                        title="Detect My Location"><i class="fa-solid fa-crosshairs"></i></button>
                </div>
            </div>
        </div>

        <div class="flex gap-6 text-sm font-mono bg-gray-900/50 px-4 py-1 rounded-lg border border-gray-700">
            <div class="flex flex-col items-center w-24"><span
                    class="text-gray-500 text-[10px] uppercase tracking-wider">DC Capacity</span><span id="stat-dc-cap"
                    class="text-yellow-400 font-bold">0 kWp</span></div>
            <div class="w-px bg-gray-700 h-8"></div>
            <div class="flex flex-col items-center w-24"><span
                    class="text-gray-500 text-[10px] uppercase tracking-wider">AC Output</span><span id="stat-ac-cap"
                    class="text-blue-400 font-bold">0 kW</span></div>
            <div class="w-px bg-gray-700 h-8"></div>
            <div class="flex flex-col items-center w-24"><span
                    class="text-gray-500 text-[10px] uppercase tracking-wider">Est. Cost</span><span id="stat-cost"
                    class="text-green-400 font-bold">₹0</span></div>
        </div>

        <div class="flex gap-3 items-center">
            <div class="flex items-center gap-2 mr-2">
                <button onclick="app.toggleGrid()" id="btn-grid-toggle"
                    class="text-xs bg-blue-600 px-2 py-1 rounded text-white border border-gray-600 hover:bg-blue-500 flex items-center gap-2"><i
                        class="fa-solid fa-border-all"></i> Grid</button>
                <button onclick="app.toggleCableMode()" id="btn-cable-mode"
                    class="text-xs bg-gray-700 px-2 py-1 rounded text-white border border-gray-600 hover:bg-gray-600 flex items-center gap-2"><i
                        class="fa-solid fa-bezier-curve"></i> Straight</button>
            </div>

            <div class="flex bg-gray-700 rounded border border-gray-600 mr-2">
                <button onclick="app.saveProject()"
                    class="px-3 py-1 hover:bg-gray-600 border-r border-gray-600 transition" title="Save JSON"><i
                        class="fa-solid fa-download"></i></button>
                <button onclick="document.getElementById('file-input').click()"
                    class="px-3 py-1 hover:bg-gray-600 border-r border-gray-600 transition" title="Load JSON"><i
                        class="fa-solid fa-upload"></i></button>
                <button class="px-3 py-1 hover:bg-gray-600 transition opacity-50 cursor-not-allowed"
                    title="Import from Google Maps (Coming Soon)"><i class="fa-solid fa-map-location-dot"></i></button>
                <input type="file" id="file-input" hidden accept=".json" onchange="app.loadProject(this)">
            </div>

            <div class="flex bg-gray-700 rounded border border-gray-600 mr-2">
                <button onclick="app.rotateSelection()"
                    class="px-3 py-1 hover:bg-gray-600 border-r border-gray-600 transition text-white"
                    title="Rotate (R)"><i class="fa-solid fa-rotate"></i></button>
                <button id="btn-copy" onclick="app.copy()"
                    class="px-3 py-1 hover:bg-gray-600 border-r border-gray-600 transition" title="Copy (Ctrl+C)"><i
                        class="fa-regular fa-copy"></i></button>
                <button id="btn-paste" onclick="app.paste()" class="px-3 py-1 hover:bg-gray-600 transition"
                    title="Paste (Ctrl+V)"><i class="fa-regular fa-paste"></i></button>
            </div>
            <div class="flex bg-gray-700 rounded border border-gray-600 mr-2">
                <button id="btn-undo" onclick="app.undo()"
                    class="px-3 py-1 hover:bg-gray-600 border-r border-gray-600 transition disabled:opacity-30"><i
                        class="fa-solid fa-rotate-left"></i></button>
                <button id="btn-redo" onclick="app.redo()"
                    class="px-3 py-1 hover:bg-gray-600 transition disabled:opacity-30"><i
                        class="fa-solid fa-rotate-right"></i></button>
            </div>
            <div class="flex bg-gray-700 rounded border border-gray-600 mr-2">
                <button onclick="app.toggleTheme('dark')"
                    class="px-3 py-1 hover:bg-gray-600 border-r border-gray-600 transition text-white"
                    title="Dark Mode"><i class="fa-solid fa-moon"></i></button>
                <button onclick="app.toggleTheme('light')"
                    class="px-3 py-1 hover:bg-gray-600 border-r border-gray-600 transition text-white"
                    title="Light Mode"><i class="fa-solid fa-sun"></i></button>
                <button onclick="app.toggleTheme('sepia')" class="px-3 py-1 hover:bg-gray-600 transition text-white"
                    title="Sepia Mode"><i class="fa-solid fa-mug-hot"></i></button>
            </div>
            <button onclick="app.resetMap()"
                class="bg-gray-700 hover:bg-red-600 text-white px-3 py-1 rounded text-sm transition border border-gray-600"><i
                    class="fa-solid fa-trash"></i> Clear</button>
            <button onclick="app.runSimulation()"
                class="bg-green-600 hover:bg-green-700 text-white px-4 py-1 rounded text-sm font-bold shadow-lg shadow-green-900/50 transition flex items-center gap-2 border border-green-500"><i
                    class="fa-solid fa-play"></i> Evaluate</button>
        </div>
    </div>
    <!-- Shortcuts Bar -->
    <div
        class="bg-gray-800 border-b border-gray-700 px-4 py-1 flex gap-4 text-[10px] text-gray-400 font-mono overflow-x-auto whitespace-nowrap shrink-0">
        <span class="font-bold text-gray-500 uppercase">Shortcuts:</span>
        <span><span class="text-yellow-500">[V]</span> Select</span>
        <span><span class="text-yellow-500">[M]</span> Measure</span>
        <span><span class="text-yellow-500">[D]</span> Delete</span>
        <span><span class="text-yellow-500">[W]</span> DC Wire</span>
        <span><span class="text-yellow-500">[A]</span> AC Wire</span>
        <span><span class="text-yellow-500">[G]</span> Earthing</span>
        <span><span class="text-yellow-500">[R]</span> Rotate</span>
        <span><span class="text-yellow-500">[Ctrl+S]</span> Save</span>
        <span><span class="text-yellow-500">[Del]</span> Remove Item</span>
    </div>

    <!-- Main Content -->
    <div class="flex flex-1 overflow-hidden relative">
        <!-- Sidebar -->
        <div class="w-80 bg-white text-gray-800 flex flex-col border-r border-gray-700 shrink-0 z-10 overflow-y-auto pb-20 shadow-xl"
            id="sidebar">

            <!-- Scenario & Load -->
            <div class="p-3 border-b border-gray-200 bg-gray-50 space-y-2">
                <div>
                    <label class="text-[10px] font-bold text-gray-500 uppercase tracking-wider">Project Scenario</label>
                    <select id="scenario-select" onchange="app.loadScenario(this.value)"
                        class="w-full mt-1 p-1.5 border border-gray-300 rounded bg-white text-sm focus:outline-none focus:border-blue-500">
                        <option value="blank">Blank Canvas (Custom)</option>
                        <option value="residential">Residential Rooftop</option>
                        <option value="commercial">Commercial Ground Mount</option>
                    </select>
                </div>
            </div>

            <!-- Financials -->
            <div class="p-3 border-b border-gray-200 bg-green-50 space-y-2">
                <label class="text-[10px] font-bold text-green-800 uppercase tracking-wider">Financials (INR)</label>
                <div class="grid grid-cols-2 gap-2">
                    <div>
                        <label class="text-[10px] font-bold text-gray-500 uppercase">Grid Rate (₹/Unit)</label>
                        <input type="number" id="input-rate" value="8.50" step="0.1"
                            class="w-full mt-1 p-1 border rounded text-xs">
                    </div>
                    <div>
                        <label class="text-[10px] font-bold text-gray-500 uppercase">Load (Units/Mo)</label>
                        <input type="number" id="input-load" value="500" class="w-full mt-1 p-1 border rounded text-xs">
                    </div>
                </div>
                <div>
                    <div class="flex justify-between">
                        <label class="text-[10px] font-bold text-gray-500 uppercase">Plant Cost (₹)</label>
                        <span class="text-[9px] text-gray-400 cursor-pointer underline"
                            onclick="app.resetCost()">Auto</span>
                    </div>
                    <input type="number" id="input-plant-cost"
                        class="w-full mt-1 p-1 border rounded text-xs font-bold text-green-700"
                        placeholder="Auto Calculated">
                </div>
            </div>

            <!-- Layers -->
            <div class="flex-1 flex flex-col min-h-[150px] max-h-[200px] border-b border-gray-200">
                <div class="p-2 bg-gray-50 border-b border-gray-100 flex justify-between items-center">
                    <label class="text-[10px] font-bold text-gray-500 uppercase tracking-wider">Layers</label>
                    <div class="flex gap-1">
                        <button onclick="app.groupSelected()"
                            class="text-[9px] bg-gray-200 hover:bg-gray-300 px-1.5 py-0.5 rounded border border-gray-300"
                            title="Group Selected"><i class="fa-solid fa-link"></i> Group</button>
                        <button onclick="app.ungroupSelected()"
                            class="text-[9px] bg-gray-200 hover:bg-gray-300 px-1.5 py-0.5 rounded border border-gray-300"
                            title="Ungroup Selected"><i class="fa-solid fa-link-slash"></i></button>
                    </div>
                </div>
                <div id="layers-list" class="flex-1 overflow-y-auto bg-white"></div>
            </div>

            <!-- Properties (Moved to Right Panel) -->

            <!-- Tools -->
            <div class="flex flex-col p-2 space-y-4">

                <!-- Basic Tools -->
                <div>
                    <div class="text-[10px] font-bold text-gray-400 uppercase tracking-wider px-1 mb-1">Main Tools</div>
                    <div class="grid grid-cols-3 gap-1">
                        <button onclick="app.setMode('select')" id="btn-select"
                            class="sidebar-item p-2 rounded border border-gray-200 flex flex-col items-center gap-1 text-[10px] font-medium selected">
                            <i class="fa-solid fa-arrow-pointer text-base text-gray-600"></i> Select
                        </button>
                        <button onclick="app.setMode('measure')" id="btn-measure"
                            class="sidebar-item p-2 rounded border border-gray-200 flex flex-col items-center gap-1 text-[10px] font-medium">
                            <i class="fa-solid fa-ruler-combined text-base text-blue-600"></i> Measure
                        </button>
                        <button onclick="app.setMode('delete')" id="btn-delete"
                            class="sidebar-item p-2 rounded border border-gray-200 flex flex-col items-center gap-1 text-[10px] font-medium hover:bg-red-50 hover:text-red-600 hover:border-red-200">
                            <i class="fa-solid fa-eraser text-base"></i> Delete
                        </button>
                    </div>
                    <div class="grid grid-cols-3 gap-1 mt-1">
                        <button onclick="app.setMode('wire_dc')" id="btn-wire_dc"
                            class="sidebar-item p-2 rounded border border-gray-200 flex flex-col items-center gap-1 text-[10px] font-medium">
                            <i class="fa-solid fa-bezier-curve text-base text-red-500"></i> DC Wire
                        </button>
                        <button onclick="app.setMode('wire_ac')" id="btn-wire_ac"
                            class="sidebar-item p-2 rounded border border-gray-200 flex flex-col items-center gap-1 text-[10px] font-medium">
                            <i class="fa-solid fa-bolt text-base text-yellow-500"></i> AC Wire
                        </button>
                        <button onclick="app.setMode('earthing')" id="btn-earthing"
                            class="sidebar-item p-2 rounded border border-gray-200 flex flex-col items-center gap-1 text-[10px] font-medium">
                            <i class="fa-solid fa-leaf text-base text-green-600"></i> Earthing
                        </button>
                    </div>
                </div>

                <!-- PV Modules -->
                <div>
                    <div class="flex justify-between items-center px-1 mb-1">
                        <span class="text-[10px] font-bold text-gray-400 uppercase tracking-wider">PV Modules</span>
                        <button onclick="app.openCreateModal('panel')"
                            class="text-xs bg-blue-100 text-blue-600 px-2 py-0.5 rounded hover:bg-blue-200"><i
                                class="fa-solid fa-plus"></i></button>
                    </div>
                    <div class="space-y-1 h-64 overflow-y-auto pr-1" id="tools-panel-list">
                        <div onclick="app.setTool('panel_330')" id="tool-panel_330"
                            class="sidebar-item p-2 rounded border border-gray-200 cursor-pointer flex items-center gap-3">
                            <div class="w-6 h-8 bg-blue-800 border border-blue-300 relative shrink-0"></div>
                            <div>
                                <div class="font-bold text-sm">330W Poly</div>
                                <div class="text-[10px] text-gray-500">2.0m x 1.0m • ₹9000</div>
                            </div>
                        </div>
                        <div onclick="app.setTool('panel_400')" id="tool-panel_400"
                            class="sidebar-item p-2 rounded border border-gray-200 cursor-pointer flex items-center gap-3">
                            <div class="w-6 h-9 bg-blue-900 border border-blue-400 relative shrink-0"></div>
                            <div>
                                <div class="font-bold text-sm">400W Mono</div>
                                <div class="text-[10px] text-gray-500">2.0m x 1.0m • ₹11000</div>
                            </div>
                        </div>
                        <div onclick="app.setTool('panel_500')" id="tool-panel_500"
                            class="sidebar-item p-2 rounded border border-gray-200 cursor-pointer flex items-center gap-3">
                            <div class="w-6 h-10 bg-black border border-gray-600 relative shrink-0"></div>
                            <div>
                                <div class="font-bold text-sm">500W Mono</div>
                                <div class="text-[10px] text-gray-500">2.2m x 1.1m • ₹14000</div>
                            </div>
                        </div>
                        <div onclick="app.setTool('panel_585')" id="tool-panel_585"
                            class="sidebar-item p-2 rounded border border-gray-200 cursor-pointer flex items-center gap-3">
                            <div class="w-6 h-10 bg-blue-900 border border-blue-400 relative shrink-0"></div>
                            <div>
                                <div class="font-bold text-sm">585W Bifacial</div>
                                <div class="text-[10px] text-gray-500">2.3m x 1.1m • ₹16000</div>
                            </div>
                        </div>
                        <div onclick="app.setTool('panel_730')" id="tool-panel_730"
                            class="sidebar-item p-2 rounded border border-gray-200 cursor-pointer flex items-center gap-3">
                            <div class="w-8 h-12 bg-blue-950 border border-blue-500 relative shrink-0"></div>
                            <div>
                                <div class="font-bold text-sm">730W Bifacial</div>
                                <div class="text-[10px] text-gray-500">2.4m x 1.3m • ₹22000</div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Electrical -->
                <div>
                    <div class="flex justify-between items-center px-1 mb-1">
                        <span class="text-[10px] font-bold text-gray-400 uppercase tracking-wider">Electrical &
                            Grid</span>
                        <button onclick="app.openCreateModal('inverter')"
                            class="text-xs bg-blue-100 text-blue-600 px-2 py-0.5 rounded hover:bg-blue-200"><i
                                class="fa-solid fa-plus"></i></button>
                    </div>
                    <div class="grid grid-cols-2 gap-1 h-64 overflow-y-auto pr-1" id="tools-elec-list">
                        <div onclick="app.setTool('inv_micro')" id="tool-inv_micro"
                            class="sidebar-item p-2 rounded border border-gray-200 cursor-pointer text-center">
                            <div class="font-bold text-[10px]">Micro Inv</div>
                        </div>
                        <div onclick="app.setTool('inv_string_3')" id="tool-inv_string_3"
                            class="sidebar-item p-2 rounded border border-gray-200 cursor-pointer text-center">
                            <div class="font-bold text-[10px]">3kW String</div>
                        </div>
                        <div onclick="app.setTool('inv_string_5')" id="tool-inv_string_5"
                            class="sidebar-item p-2 rounded border border-gray-200 cursor-pointer text-center">
                            <div class="font-bold text-[10px]">5kW String</div>
                        </div>
                        <div onclick="app.setTool('inv_string_10')" id="tool-inv_string_10"
                            class="sidebar-item p-2 rounded border border-gray-200 cursor-pointer text-center">
                            <div class="font-bold text-[10px]">10kW String</div>
                        </div>
                        <div onclick="app.setTool('inv_string_25')" id="tool-inv_string_25"
                            class="sidebar-item p-2 rounded border border-gray-200 cursor-pointer text-center">
                            <div class="font-bold text-[10px]">25kW String</div>
                        </div>
                        <div onclick="app.setTool('inv_string_50')" id="tool-inv_string_50"
                            class="sidebar-item p-2 rounded border border-gray-200 cursor-pointer text-center">
                            <div class="font-bold text-[10px]">50kW String</div>
                        </div>
                        <div onclick="app.setTool('inv_string_100')" id="tool-inv_string_100"
                            class="sidebar-item p-2 rounded border border-gray-200 cursor-pointer text-center bg-red-50">
                            <div class="font-bold text-[10px]">100kW Inv</div>
                        </div>
                        <div onclick="app.setTool('acdb_switch')" id="tool-acdb_switch"
                            class="sidebar-item p-2 rounded border border-gray-200 cursor-pointer text-center bg-gray-100">
                            <div class="font-bold text-[10px]">ACDB (Switch)</div>
                        </div>
                        <div onclick="app.setTool('lt_panel')" id="tool-lt_panel"
                            class="sidebar-item p-2 rounded border border-gray-200 cursor-pointer text-center bg-gray-100">
                            <div class="font-bold text-[10px]">LT Panel</div>
                        </div>
                        <div onclick="app.setTool('ht_panel')" id="tool-ht_panel"
                            class="sidebar-item p-2 rounded border border-gray-200 cursor-pointer text-center bg-gray-200">
                            <div class="font-bold text-[10px]">HT Panel</div>
                        </div>
                        <div onclick="app.setTool('load_box')" id="tool-load_box"
                            class="sidebar-item p-2 rounded border border-gray-200 cursor-pointer text-center bg-orange-50 text-orange-900">
                            <div class="font-bold text-[10px]">Load (Consumer)</div>
                        </div>
                        <div onclick="app.setTool('meter_net')" id="tool-meter_net"
                            class="sidebar-item p-2 rounded border border-gray-200 cursor-pointer text-center bg-green-50 text-green-800">
                            <div class="font-bold text-[10px]">Net Meter</div>
                        </div>
                        <div onclick="app.setTool('grid_point')" id="tool-grid_point"
                            class="sidebar-item p-2 rounded border border-gray-200 cursor-pointer text-center bg-green-100 text-green-900">
                            <div class="font-bold text-[10px]">Grid Point</div>
                        </div>
                        <div onclick="app.setTool('meter_gross')" id="tool-meter_gross"
                            class="sidebar-item p-2 rounded border border-gray-200 cursor-pointer text-center bg-green-50 text-green-800">
                            <div class="font-bold text-[10px]">Gross Meter</div>
                        </div>
                        <div onclick="app.setTool('meter_gross')" id="tool-meter_gross"
                            class="sidebar-item p-2 rounded border border-gray-200 cursor-pointer text-center bg-green-50 text-green-800">
                            <div class="font-bold text-[10px]">Gross Meter</div>
                        </div>
                        <div onclick="app.setTool('battery_5kw')" id="tool-battery_5kw"
                            class="sidebar-item p-2 rounded border border-gray-200 cursor-pointer text-center bg-green-50 text-green-900">
                            <div class="font-bold text-[10px]">Battery 5kWh</div>
                        </div>
                        <div onclick="app.setTool('trans_11kv')" id="tool-trans_11kv"
                            class="sidebar-item p-2 rounded border border-gray-200 cursor-pointer text-center bg-yellow-50">
                            <div class="font-bold text-[10px]">11kV Transf.</div>
                        </div>
                        <div onclick="app.setTool('earth_pit')" id="tool-earth_pit"
                            class="sidebar-item p-2 rounded border border-gray-200 cursor-pointer text-center">
                            <div class="font-bold text-[10px]">Earth Pit</div>
                        </div>
                    </div>
                </div>

                <!-- Environment -->
                <div>
                    <div class="text-[10px] font-bold text-gray-400 uppercase tracking-wider px-1 mb-1">Structures</div>
                    <div class="grid grid-cols-2 gap-1">
                        <button onclick="app.setDrawMode('roof')" id="btn-draw_roof"
                            class="sidebar-item p-2 rounded border border-gray-200 flex items-center gap-2 text-xs text-left">
                            <div class="w-3 h-3 bg-gray-600 rounded-sm"></div> RCC Roof
                        </button>
                        <button onclick="app.setDrawMode('tinshed')" id="btn-draw_tinshed"
                            class="sidebar-item p-2 rounded border border-gray-200 flex items-center gap-2 text-xs text-left">
                            <div class="w-3 h-3 bg-blue-200 rounded-sm"></div> Tin Shed
                        </button>
                        <button onclick="app.setDrawMode('building')" id="btn-draw_building"
                            class="sidebar-item p-2 rounded border border-gray-200 flex items-center gap-2 text-xs text-left">
                            <div class="w-3 h-3 bg-gray-400 rounded-sm"></div> Building
                        </button>
                        <button onclick="app.setDrawMode('tree')" id="btn-draw_tree"
                            class="sidebar-item p-2 rounded border border-gray-200 flex items-center gap-2 text-xs text-left">
                            <div class="w-3 h-3 bg-green-500 rounded-full"></div> Tree Area
                        </button>
                        <button onclick="app.setDrawMode('obstacle')" id="btn-draw_obstacle"
                            class="sidebar-item p-2 rounded border border-gray-200 flex items-center gap-2 text-xs text-left col-span-2">
                            <div class="w-3 h-3 bg-red-400 rounded-sm"></div> Chimney / Obstruction
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Canvas Area -->
        <div class="flex-1 bg-gray-800 relative overflow-hidden" id="canvas-container">
            <canvas id="gameCanvas" class="absolute top-0 left-0"></canvas>
            <div
                class="absolute bottom-4 left-4 bg-gray-900/90 p-3 rounded-lg border border-gray-600 w-52 backdrop-blur-sm z-10">
                <div class="flex justify-between items-center text-xs text-gray-300 mb-2 font-bold uppercase">
                    <span class="flex items-center gap-2"><i class="fa-solid fa-sun text-yellow-500 text-lg"></i> Sun
                        Position</span>
                    <span id="time-display" class="font-mono text-yellow-400">12:00 PM</span>
                </div>
                <input type="range" min="6" max="18" step="0.1" value="12" id="sun-slider"
                    oninput="app.setSunTime(this.value)">
                <div class="flex justify-between text-[10px] text-gray-500 mt-1">
                    <span>Sunrise</span><span>Noon</span><span>Sunset</span>
                </div>
                <div class="border-t border-gray-700 mt-3 pt-2">
                    <label class="text-[10px] font-bold text-gray-400 uppercase">Orientation (North)</label>
                    <input type="range" min="0" max="360" value="0" class="w-full mt-1"
                        oninput="app.setOrientation(this.value)">
                    <div class="flex justify-between text-[9px] text-gray-500">
                        <span>0° (Up)</span><span id="orient-disp">0°</span><span>360°</span>
                    </div>
                </div>

                <!-- Playback Controls -->
                <div class="mt-3 pt-2 border-t border-gray-700">
                    <div class="flex items-center justify-between mb-2">
                        <span class="text-[10px] text-gray-400 uppercase font-bold">Simulation</span>
                        <button onclick="app.resetSimulation()" class="text-[10px] text-blue-400 hover:text-blue-300"><i
                                class="fa-solid fa-rotate-right"></i> Reset</button>
                    </div>
                    <div class="flex items-center gap-2 mb-2">
                        <select id="sim-month" onchange="app.setSimMonth(this.value)"
                            class="bg-gray-800 text-gray-300 text-[10px] border border-gray-600 rounded px-1 py-0.5 w-16">
                            <option value="0">Jan</option>
                            <option value="1">Feb</option>
                            <option value="2">Mar</option>
                            <option value="3">Apr</option>
                            <option value="4">May</option>
                            <option value="5">Jun</option>
                            <option value="6">Jul</option>
                            <option value="7">Aug</option>
                            <option value="8">Sep</option>
                            <option value="9">Oct</option>
                            <option value="10">Nov</option>
                            <option value="11">Dec</option>
                        </select>
                        <div class="text-xs font-mono text-yellow-400 flex-1 text-right" id="sim-power">0 kW</div>
                    </div>
                    <div class="flex items-center gap-2 mb-2">
                        <button onclick="app.togglePlayback()" id="btn-play"
                            class="bg-blue-600 hover:bg-blue-500 text-white rounded px-2 py-1 text-xs w-8 transition"><i
                                class="fa-solid fa-play"></i></button>
                        <input type="range" min="1" max="100" value="10" id="sim-speed"
                            class="w-full h-1 bg-gray-600 rounded-lg appearance-none cursor-pointer"
                            oninput="app.setSpeed(this.value)" title="Speed">
                    </div>
                    <div class="grid grid-cols-2 gap-2 text-[9px] text-gray-400">
                        <div>Day: <span id="sim-day-gen" class="text-white">0</span> kWh</div>
                        <div>Total: <span id="sim-total-gen" class="text-white">0</span> MWh</div>
                    </div>
                    <div class="mt-2 pt-2 border-t border-gray-700 flex justify-between items-center">
                        <div class="flex items-center gap-2">
                            <span id="sim-weather-icon"><i class="fa-solid fa-sun text-yellow-400"></i></span>
                            <span id="sim-irradiance" class="text-[10px] font-mono text-yellow-200">0 W/m²</span>
                        </div>
                        <div class="text-[9px] text-gray-500">Live Weather</div>
                    </div>

                    <!-- Google Maps Integration -->
                    <div class="mt-3 pt-2 border-t border-gray-700">
                        <div class="flex justify-between items-center mb-1">
                            <span class="text-[10px] font-bold text-gray-400 uppercase">Map Overlay</span>
                            <button onclick="document.getElementById('map-modal').classList.remove('hidden')"
                                class="text-[10px] text-blue-400 hover:text-blue-300"><i class="fa-solid fa-map"></i>
                                Setup</button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Right Details Panel -->
            <div id="right-panel"
                class="absolute top-0 right-0 h-full w-64 bg-white border-l border-gray-200 shadow-2xl transform transition-transform translate-x-full z-20 flex flex-col">
                <div class="p-3 bg-gray-50 border-b border-gray-200 flex justify-between items-center">
                    <h3 class="font-bold text-gray-700 uppercase text-xs tracking-wider">Object Details</h3>
                    <button onclick="app.closeRightPanel()" class="text-gray-400 hover:text-gray-600"><i
                            class="fa-solid fa-xmark"></i></button>
                </div>
                <div class="p-4 flex-1 overflow-y-auto space-y-4" id="right-panel-content">
                    <!-- Content populated by JS -->
                </div>
                <div class="p-3 border-t border-gray-200 bg-gray-50">
                    <button onclick="app.deleteAt(null, app.selectedObjectId)"
                        class="w-full bg-red-50 text-red-600 border border-red-200 rounded py-2 text-xs font-bold hover:bg-red-100 transition"><i
                            class="fa-solid fa-trash mr-2"></i> Delete Object</button>
                </div>
            </div>
            <div
                class="absolute bottom-4 right-4 bg-gray-900/80 p-3 rounded text-xs text-gray-300 border border-gray-700 select-none pointer-events-none">
                <div class="flex items-center gap-2 mb-2 border-b border-gray-700 pb-2">
                    <div class="w-8 h-8 relative border-2 border-gray-500 rounded-full flex items-center justify-center text-[10px] font-bold text-gray-500"
                        id="compass-icon" style="transition: transform 0.3s">E<div
                            class="absolute -right-1 top-1/2 w-2 h-0.5 bg-red-500"></div>
                    </div>
                    <div>
                        <div class="font-bold text-white">Orientation</div>
                        <div class="text-gray-500 text-[10px]">East Indicator</div>
                    </div>
                </div>
                <div class="flex items-center gap-2 mb-1">
                    <div class="w-3 h-3 bg-yellow-500/20 border border-yellow-500 rounded-full"></div> Sun Path
                </div>
                <div class="flex items-center gap-2 mb-1">
                    <div class="w-3 h-3 bg-black/50 border border-black"></div> Shadow (Ground)
                </div>
                <div class="flex items-center gap-2 mb-1">
                    <div class="w-3 h-3 bg-black/30 border border-black"></div> Shadow (Roof)
                </div>

                <!-- Playback Controls -->
                <div class="mt-3 pt-3 border-t border-gray-700">
                    <!-- <div class="flex items-center justify-between mb-2">
                        <span class="text-[10px] text-gray-400 uppercase font-bold">Simulation</span>
                        <div class="text-xs font-mono text-yellow-400" id="sim-power">0 kW</div>
                    </div> -->
                    <div class="flex items-center gap-2">
                        <button onclick="app.togglePlayback()" id="btn-play"
                            class="bg-blue-600 hover:bg-blue-500 text-white rounded px-2 py-1 text-xs w-8 transition"><i
                                class="fa-solid fa-play"></i></button>
                        <input type="range" min="1" max="100" value="10"
                            class="w-full h-1 bg-gray-600 rounded-lg appearance-none cursor-pointer"
                            oninput="app.setSpeed(this.value)" title="Speed">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Custom Component Modal -->
    <div id="create-modal" class="fixed inset-0 modal-overlay z-50 hidden flex items-center justify-center">
        <div class="bg-white rounded-lg shadow-xl w-96 p-6 text-gray-800">
            <h2 class="text-lg font-bold mb-4 border-b pb-2">Add New Component</h2>
            <div class="space-y-3">
                <div><label class="block text-xs font-bold text-gray-500">Name</label><input type="text" id="new-name"
                        class="w-full border p-2 rounded text-sm" placeholder="e.g. 600W Bifacial"></div>
                <div class="grid grid-cols-2 gap-3">
                    <div><label class="block text-xs font-bold text-gray-500">Type</label><select id="new-type"
                            class="w-full border p-2 rounded text-sm">
                            <option value="panel">Solar Panel</option>
                            <option value="inverter">Inverter</option>
                            <option value="battery">Battery</option>
                        </select></div>
                    <div><label class="block text-xs font-bold text-gray-500">Color</label><input type="color"
                            id="new-color" class="w-full h-9 p-1 border rounded" value="#1e3a8a"></div>
                </div>
                <div class="grid grid-cols-2 gap-3">
                    <div><label class="block text-xs font-bold text-gray-500">Width (m)</label><input type="number"
                            id="new-w" class="w-full border p-2 rounded text-sm" value="1.1"></div>
                    <div><label class="block text-xs font-bold text-gray-500">Height (m)</label><input type="number"
                            id="new-h" class="w-full border p-2 rounded text-sm" value="2.3"></div>
                </div>
                <div class="grid grid-cols-2 gap-3">
                    <div><label class="block text-xs font-bold text-gray-500">Capacity (W/kW)</label><input
                            type="number" id="new-cap" class="w-full border p-2 rounded text-sm" value="600"></div>
                    <div><label class="block text-xs font-bold text-gray-500">Cost (₹)</label><input type="number"
                            id="new-cost" class="w-full border p-2 rounded text-sm" value="18000"></div>
                </div>
            </div>
            <div class="mt-6 flex justify-end gap-2">
                <button onclick="document.getElementById('create-modal').classList.add('hidden')"
                    class="px-4 py-2 text-gray-500 hover:bg-gray-100 rounded text-sm">Cancel</button>
                <button onclick="app.addCustomComponent()"
                    class="px-4 py-2 bg-blue-600 text-white rounded text-sm hover:bg-blue-700">Add Component</button>
            </div>
        </div>
    </div>

    <!-- Eval Modal -->
    <div id="map-modal" class="fixed inset-0 bg-black/80 z-50 hidden flex items-center justify-center backdrop-blur-sm">
        <div class="bg-white rounded-lg shadow-xl w-96 p-6 text-gray-800">
            <h2 class="text-lg font-bold mb-4 border-b pb-2">Google Maps Setup</h2>
            <div class="space-y-4">
                <div>
                    <label class="block text-xs font-bold text-gray-500">API Key (Static Maps & Geocoding)</label>
                    <input type="password" id="map-api-key" class="w-full border p-2 rounded text-sm"
                        placeholder="AIzaSy...">
                    <div class="text-[10px] text-gray-400 mt-1">Required for fetching map images and searching
                        locations.</div>
                </div>
                <div>
                    <label class="block text-xs font-bold text-gray-500">Gemini API Key (AI Import)</label>
                    <input type="password" id="gemini-api-key" class="w-full border p-2 rounded text-sm"
                        placeholder="AIzaSy...">
                    <div class="text-[10px] text-gray-400 mt-1">Required for AI-powered building extraction.</div>
                </div>
                <div>
                    <label class="block text-xs font-bold text-gray-500">AI Extraction Mode</label>
                    <select id="gemini-mode" class="w-full border p-2 rounded text-sm">
                        <option value="building">Building Only</option>
                        <option value="surroundings">Building + Surroundings</option>
                    </select>
                </div>
                <div>
                    <label class="block text-xs font-bold text-gray-500">Search Location</label>
                    <div class="flex gap-2">
                        <input type="text" id="map-search-query" class="w-full border p-2 rounded text-sm"
                            placeholder="E.g. Eiffel Tower, Paris">
                        <button onclick="app.searchLocation()"
                            class="bg-blue-100 text-blue-600 px-3 rounded hover:bg-blue-200"><i
                                class="fa-solid fa-search"></i></button>
                    </div>
                </div>
                <div>
                    <label class="block text-xs font-bold text-gray-500">Zoom Level</label>
                    <input type="number" id="map-zoom" class="w-full border p-2 rounded text-sm" value="20" min="15"
                        max="22">
                </div>
                <div class="flex gap-2">
                    <button onclick="app.loadMapOverlay()"
                        class="flex-1 bg-blue-600 hover:bg-blue-700 text-white py-2 rounded font-bold text-sm">Load
                        Map</button>
                    <button onclick="app.importBuildings()"
                        class="flex-1 bg-green-600 hover:bg-green-700 text-white py-2 rounded font-bold text-sm"
                        title="Import 3D Buildings from OpenStreetMap">Import Buildings</button>
                    <button onclick="document.getElementById('map-modal').classList.add('hidden')"
                        class="flex-1 bg-gray-200 hover:bg-gray-300 text-gray-800 py-2 rounded font-bold text-sm">Cancel</button>
                </div>
            </div>
        </div>
    </div>

    <div id="create-modal"
        class="fixed inset-0 bg-black/80 z-50 hidden flex items-center justify-center backdrop-blur-sm">
        <div
            class="bg-white text-gray-800 rounded-xl shadow-2xl max-w-5xl w-full mx-4 overflow-hidden flex flex-col max-h-[90vh]">
            <div class="p-5 bg-gray-900 text-white flex justify-between items-center border-b border-gray-700">
                <h2 class="text-xl font-bold"><i class="fa-solid fa-chart-line text-yellow-500 mr-2"></i> Performance
                    Report</h2>
                <button onclick="document.getElementById('eval-modal').classList.add('hidden')"
                    class="hover:text-gray-300 transition"><i class="fa-solid fa-xmark text-xl"></i></button>
            </div>
            <div class="p-6 overflow-y-auto grid grid-cols-4 gap-6">

                <!-- Commercial Option -->
                <div class="col-span-4 bg-blue-50 p-3 rounded border border-blue-100 flex items-center gap-3">
                    <input type="checkbox" id="check-commercial" class="w-4 h-4 text-blue-600 rounded cursor-pointer">
                    <div>
                        <div class="text-sm font-bold text-blue-900">Commercial / Industrial Project</div>
                        <div class="text-xs text-blue-700">Apply Accelerated Depreciation (40%) benefit in financial
                            analysis.</div>
                    </div>
                </div>

                <!-- Left: Score & Stats -->
                <div class="col-span-1 space-y-4">
                    <div class="bg-gray-50 p-4 rounded-lg border border-gray-200 text-center">
                        <div id="eval-score-circle"
                            class="w-24 h-24 rounded-full border-8 border-green-500 flex items-center justify-center text-3xl font-bold text-green-600 mx-auto mb-2">
                            95%</div>
                        <h3 id="eval-verdict" class="text-lg font-bold mb-1 text-gray-900">System Optimized</h3>
                        <p id="eval-summary" class="text-gray-500 text-xs">Ready for commissioning.</p>
                    </div>
                    <div class="p-3 bg-blue-50 rounded border border-blue-100">
                        <div class="text-xs text-blue-800 uppercase font-bold">System Size</div>
                        <div id="eval-dc-size" class="text-xl font-mono font-bold text-blue-600">0 kWp</div>
                    </div>
                    <div class="p-3 bg-purple-50 rounded border border-purple-100">
                        <div class="text-xs text-purple-800 uppercase font-bold">Annual Generation</div>
                        <div id="eval-annual-gen" class="text-xl font-mono font-bold text-purple-600">0 MWh</div>
                    </div>
                </div>

                <!-- Middle: Charts -->
                <div class="col-span-3 space-y-4">
                    <div class="h-48 bg-white border border-gray-200 rounded p-2"><canvas id="genChart"></canvas></div>
                    <div class="h-48 bg-white border border-gray-200 rounded p-2"><canvas id="roiChart"></canvas></div>
                    <div class="h-48 bg-white border border-gray-200 rounded p-2"><canvas id="lossChart"></canvas></div>
                </div>

                <!-- Bottom: Monthly Table -->
                <div class="col-span-4 border-t pt-4">
                    <h4 class="font-bold text-gray-500 text-xs uppercase mb-3 tracking-wider">Monthly Breakdown (Net vs
                        Gross Metering)</h4>
                    <div class="overflow-x-auto rounded border border-gray-200">
                        <table class="w-full text-xs text-left text-gray-700">
                            <thead class="bg-gray-100 font-bold uppercase text-gray-500">
                                <tr>
                                    <th class="px-3 py-2">Month</th>
                                    <th class="px-3 py-2 text-right">Gross Gen (Units)</th>
                                    <th class="px-3 py-2 text-right">Load (Units)</th>
                                    <th class="px-3 py-2 text-right">Net Export (Units)</th>
                                    <th class="px-3 py-2 text-right bg-blue-50">Net Meter Saving (₹)</th>
                                    <th class="px-3 py-2 text-right bg-green-50">Gross Meter Income (₹)</th>
                                </tr>
                            </thead>
                            <tbody id="month-table-body" class="divide-y divide-gray-100 bg-white">
                                <!-- Filled by JS -->
                            </tbody>
                        </table>
                    </div>
                </div>

                <!-- Yearly Table -->
                <div class="col-span-4 border-t pt-4">
                    <h4 class="font-bold text-gray-500 text-xs uppercase mb-3 tracking-wider">25-Year Projections</h4>
                    <div class="overflow-x-auto rounded border border-gray-200 max-h-60 overflow-y-auto">
                        <table class="w-full text-xs text-left text-gray-700">
                            <thead class="bg-gray-100 font-bold uppercase text-gray-500 sticky top-0">
                                <tr>
                                    <th class="px-3 py-2">Year</th>
                                    <th class="px-3 py-2 text-right">Generation (Units)</th>
                                    <th class="px-3 py-2 text-right">Savings (₹)</th>
                                    <th class="px-3 py-2 text-right">Cumulative (₹)</th>
                                    <th class="px-3 py-2 text-right">ROI Status</th>
                                </tr>
                            </thead>
                            <tbody id="year-table-body" class="divide-y divide-gray-100 bg-white"></tbody>
                        </table>
                    </div>
                </div>

                <!-- Issues Checklist -->
                <div class="col-span-4 border-t pt-4">
                    <h4 class="font-bold text-gray-500 text-xs uppercase mb-3 tracking-wider">Critical Connectivity
                        Checks</h4>
                    <ul id="eval-list" class="text-sm space-y-2 grid grid-cols-2 gap-x-4"></ul>
                </div>
            </div>
            <div class="p-4 border-t border-gray-200 bg-gray-50 flex justify-between items-center">
                <button onclick="app.downloadReport()"
                    class="bg-green-600 hover:bg-green-700 text-white px-4 py-2 rounded shadow transition font-medium text-xs"><i
                        class="fa-solid fa-file-excel mr-2"></i> Download Detailed Report</button>
                <button onclick="document.getElementById('eval-modal').classList.add('hidden')"
                    class="bg-gray-900 hover:bg-gray-800 text-white px-6 py-2 rounded shadow transition font-medium text-xs">Return
                    to Editor</button>
            </div>
        </div>
    </div>

    <!-- Context Menu -->
    <div id="context-menu"
        class="fixed bg-white shadow-lg rounded-lg py-1 z-50 hidden w-48 text-gray-800 text-sm border border-gray-200">
        <button onclick="app.handleContextAction('import_ai')"
            class="w-full text-left px-4 py-2 hover:bg-blue-50 flex items-center gap-2">
            <i class="fa-solid fa-wand-magic-sparkles text-purple-500"></i> Import with AI
        </button>
        <button onclick="app.handleContextAction('import_osm')"
            class="w-full text-left px-4 py-2 hover:bg-blue-50 flex items-center gap-2">
            <i class="fa-solid fa-city text-blue-500"></i> Import (OSM)
        </button>
        <div class="border-t my-1"></div>
        <button onclick="app.handleContextAction('set_origin')"
            class="w-full text-left px-4 py-2 hover:bg-blue-50 flex items-center gap-2">
            <i class="fa-solid fa-crosshairs text-red-500"></i> Set Origin
        </button>
    </div>

    <script>
        if (window.currentSolarApp) window.currentSolarApp.destroy();

        const COMPONENTS = {
            'panel_330': { type: 'panel', w: 1.0, h: 2.0, watts: 330, cost: 9000, color: '#1e3a8a', structure_h: 0.5 },
            'panel_400': { type: 'panel', w: 1.0, h: 2.0, watts: 400, cost: 11000, color: '#172554', structure_h: 0.5 },
            'panel_450': { type: 'panel', w: 1.0, h: 2.1, watts: 450, cost: 12000, color: '#1e40af', structure_h: 0.5 },
            'panel_500': { type: 'panel', w: 1.1, h: 2.2, watts: 500, cost: 14000, color: '#000000', structure_h: 0.5 },
            'panel_585': { type: 'panel', w: 1.1, h: 2.3, watts: 585, cost: 16000, color: '#1e3a8a', structure_h: 0.5 },
            'panel_730': { type: 'panel', w: 1.3, h: 2.4, watts: 730, cost: 22000, color: '#172554', structure_h: 0.5 },

            'inv_micro': { type: 'inverter', subtype: 'micro', w: 0.3, h: 0.3, capKw: 0.5, cost: 8000, color: '#ef4444', h_z: 0.2 },
            'inv_string_3': { type: 'inverter', subtype: 'string', w: 0.6, h: 0.8, capKw: 3, cost: 35000, color: '#ef4444', h_z: 0.5 },
            'inv_string_5': { type: 'inverter', subtype: 'string', w: 0.6, h: 0.8, capKw: 5, cost: 45000, color: '#ef4444', h_z: 0.5 },
            'inv_string_10': { type: 'inverter', subtype: 'string', w: 0.8, h: 1, capKw: 10, cost: 85000, color: '#ef4444', h_z: 0.5 },
            'inv_string_25': { type: 'inverter', subtype: 'string', w: 1.0, h: 1.2, capKw: 25, cost: 180000, color: '#ef4444', h_z: 0.5 },
            'inv_string_50': { type: 'inverter', subtype: 'string', w: 1.2, h: 1.5, capKw: 50, cost: 350000, color: '#ef4444', h_z: 0.5 },
            'inv_string_100': { type: 'inverter', subtype: 'string', w: 1.5, h: 1.8, capKw: 100, cost: 650000, color: '#ef4444', h_z: 0.5 },
            'inv_hybrid_5': { type: 'inverter', subtype: 'hybrid', w: 0.8, h: 1, capKw: 5, cost: 65000, color: '#a855f7', h_z: 0.5 },

            'acdb_switch': { type: 'bos', subtype: 'acdb', w: 0.6, h: 0.8, cost: 15000, color: '#475569', h_z: 1.2, label: 'ACDB', isOn: true },
            'lt_panel': { type: 'bos', subtype: 'lt_panel', w: 1.0, h: 0.5, cost: 25000, color: '#4b5563', h_z: 1.5, label: 'LT Panel', isOn: true },
            'ht_panel': { type: 'bos', subtype: 'ht_panel', w: 1.2, h: 0.6, cost: 150000, color: '#374151', h_z: 1.5, label: 'HT Panel' },
            'load_box': { type: 'load', w: 1.0, h: 1.0, cost: 0, color: '#f59e0b', h_z: 0, label: 'Load', units: 500 },
            'meter_net': { type: 'bos', subtype: 'meter_net', w: 0.4, h: 0.4, cost: 15000, color: '#10b981', h_z: 1.2, label: 'Net Meter' },
            'meter_gross': { type: 'bos', subtype: 'meter_gross', w: 0.4, h: 0.4, cost: 15000, color: '#ef4444', h_z: 1.2, label: 'Gross Meter' },
            'meter_net': { type: 'grid', subtype: 'meter_net', w: 0.4, h: 0.5, cost: 8000, color: '#10b981', h_z: 0.5 },
            'meter_gross': { type: 'grid', subtype: 'meter_gross', w: 0.4, h: 0.5, cost: 5000, color: '#22c55e', h_z: 0.5 },
            'grid_point': { type: 'grid', subtype: 'pole', w: 0.5, h: 0.5, cost: 0, color: '#ffffff', h_z: 0 },
            'battery_5kw': { type: 'battery', w: 0.8, h: 1.2, capKwh: 5, cost: 120000, color: '#22c55e', h_z: 1 },
            'acdb': { type: 'bos', subtype: 'acdb', w: 0.6, h: 0.8, cost: 12000, color: '#374151', h_z: 1 },
            'trans_11kv': { type: 'bos', subtype: 'transformer', w: 1.5, h: 1.5, cost: 450000, color: '#ca8a04', voltage: '11kV', h_z: 2 },
            'trans_33kv': { type: 'bos', subtype: 'transformer', w: 2.5, h: 2.5, cost: 850000, color: '#854d0e', voltage: '33kV', h_z: 3 },
            'la': { type: 'safety', subtype: 'la', w: 0.2, h: 0.2, cost: 5000, color: '#f97316', h_z: 5 },
            'earth_pit': { type: 'safety', subtype: 'earth', w: 0.5, h: 0.5, cost: 8000, color: '#15803d', h_z: 0 },
        };

        let COLORS = { grid: '#374151', bg: '#1f2937', wire_dc: '#ef4444', wire_ac: '#eab308', earth: '#16a34a', roof: '#6b7280', tinshed: '#93c5fd', obstacle: 'rgba(239, 68, 68, 0.6)', shadow: 'rgba(0, 0, 0, 0.5)', highlight: 'rgba(59, 130, 246, 0.4)', tree: 'rgba(22, 163, 74, 0.8)', building: '#475569' };

        // --- Advanced Sun Position Algorithm (Simplified NOAA/SunCalc) ---
        class SunCalc {
            static getPosition(date, lat, lon) {
                const rad = Math.PI / 180;
                const dayMs = 1000 * 60 * 60 * 24;
                const J1970 = 2440588;
                const J2000 = 2451545;

                const J = date.valueOf() / dayMs - 0.5 + J1970;
                const d = J - J2000;

                const L = (280.16 + 0.9856235 * d) % 360;
                const g = (357.5291 + 0.98560028 * d) % 360;
                const l = (L + 1.9148 * Math.sin(g * rad) + 0.02 * Math.sin(2 * g * rad) + 0.0003 * Math.sin(3 * g * rad)) * rad; // Ecliptic long
                const eps = (23.4393 - 0.0000004 * d) * rad; // Obliquity

                const ra = Math.atan2(Math.cos(eps) * Math.sin(l), Math.cos(l));
                const dec = Math.asin(Math.sin(eps) * Math.sin(l));

                const h = (6.697375 + 0.0657098242 * d + 1.0027379 * date.getUTCHours() + date.getUTCMinutes() / 60 * 1.0027379) * 15 * rad; // GMST
                const H = h + lon * rad - ra; // Hour angle

                const az = Math.atan2(Math.sin(H), Math.cos(H) * Math.sin(lat * rad) - Math.tan(dec) * Math.cos(lat * rad));
                const alt = Math.asin(Math.sin(lat * rad) * Math.sin(dec) + Math.cos(lat * rad) * Math.cos(dec) * Math.cos(H));

                return {
                    azimuth: az + Math.PI, // 0 is South in formula, we want 0 North? Or standard 0 South. Let's align to canvas: 0 is Top (North)
                    altitude: alt
                };
            }
        }

        // --- Weather Service (Open-Meteo) ---
        class WeatherService {
            constructor() {
                this.cache = {};
            }

            async getWeather(lat, lon, date) {
                // Format date YYYY-MM-DD
                const dateStr = date.toISOString().split('T')[0];
                const key = `${lat},${lon},${dateStr}`;

                if (this.cache[key]) return this.cache[key];

                try {
                    // Fetch hourly irradiance and cloud cover
                    const url = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&hourly=direct_normal_irradiance,diffuse_radiation,cloudcover&timezone=auto&start_date=${dateStr}&end_date=${dateStr}`;
                    const resp = await fetch(url);
                    const data = await resp.json();

                    if (!data.hourly) throw new Error("No data");

                    this.cache[key] = data.hourly;
                    return data.hourly;
                } catch (e) {
                    console.error("Weather fetch failed:", e);
                    return null; // Fallback to clear sky
                }
            }
        }

        const weatherService = new WeatherService();

        class GameApp {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.scale = 25; this.offsetX = 0; this.offsetY = 0;
                this.mode = 'select'; this.objects = []; this.wires = []; this.sunTime = 12;
                this.history = []; this.historyStep = -1; this.clipboard = null;
                this.dragStart = { x: 0, y: 0 }; this.resizeHandle = null; this.isRunning = true;
                this.wireStartObj = null; this.arrayStart = null;
                this.cableMode = 'straight'; this.showGrid = true; this.orientation = 0;
                this.calculatedCost = 0;
                this.simMonth = 0; this.simDayGen = 0; this.simTotalGen = 0; this.simTotalImport = 0; this.simTotalExport = 0;
                this.isPlaying = false; this.lastFrameTime = 0; this.playbackSpeed = 10;

                // Load API Keys
                const savedMapKey = localStorage.getItem('google_maps_api_key');
                if (savedMapKey) document.getElementById('map-api-key').value = savedMapKey;

                const savedGeminiKey = localStorage.getItem('google_gemini_api_key');
                if (savedGeminiKey) document.getElementById('gemini-api-key').value = savedGeminiKey;

                // Resize Listener
                window.addEventListener('resize', () => this.resize());
                this.resize();

                // Add Input Listeners for API Keys
                document.getElementById('map-api-key').addEventListener('change', (e) => {
                    localStorage.setItem('google_maps_api_key', e.target.value);
                });
                document.getElementById('gemini-api-key').addEventListener('change', (e) => {
                    localStorage.setItem('google_gemini_api_key', e.target.value);
                });

                // Context Menu
                this.contextMenu = document.getElementById('context-menu');
                this.contextPos = { x: 0, y: 0, lat: 0, lon: 0 };

                window.addEventListener('click', () => this.contextMenu.classList.add('hidden'));
                this.canvas.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    const r = this.canvas.getBoundingClientRect();
                    const x = e.clientX - r.left;
                    const y = e.clientY - r.top;
                    const w = this.screenToWorld(x, y);

                    // Calculate Lat/Lon
                    const centerLat = parseFloat(document.getElementById('input-lat').value);
                    const centerLon = parseFloat(document.getElementById('input-lon').value);
                    if (centerLat && centerLon) {
                        const latMeters = 111320;
                        const lonMeters = 40075000 * Math.cos(centerLat * Math.PI / 180) / 360;
                        const dLat = -(w.y / latMeters);
                        const dLon = w.x / lonMeters;
                        this.contextPos = { x: e.clientX, y: e.clientY, lat: centerLat + dLat, lon: centerLon + dLon };

                        this.contextMenu.style.left = e.clientX + 'px';
                        this.contextMenu.style.top = e.clientY + 'px';
                        this.contextMenu.classList.remove('hidden');
                    }
                });

                // Keyboard Shortcuts
                this.keyHandler = (e) => {
                    if (e.key === 'Delete' || e.key === 'Backspace') this.deleteAt(null, this.selectedObjectId);
                    else if (e.ctrlKey && (e.key === 'z' || e.key === 'Z')) this.undo();
                    else if (e.ctrlKey && (e.key === 'c' || e.key === 'C')) this.copy();
                    else if (e.ctrlKey && (e.key === 'v' || e.key === 'V')) this.paste();
                    else if (e.key === 'Escape') { this.setMode('select'); this.selectedObjectId = null; this.updateUI(); }
                    else if (e.key === 's' || e.key === 'S') { this.setMode('select'); }
                    else if (e.key === 'v' || e.key === 'V') { this.setMode('select'); }
                    else if (e.key === 'm' || e.key === 'M') { this.setMode('measure'); }
                    else if (e.key === 'd' || e.key === 'D') { this.setMode('delete'); }
                    else if (e.key === 'w' || e.key === 'W') { this.setMode('wire_dc'); }
                    else if (e.key === 'a' || e.key === 'A') { this.setMode('wire_ac'); }
                    else if (e.key === 'g' || e.key === 'G') { this.setMode('earthing'); }
                };
                window.addEventListener('keydown', this.keyHandler);
                this.bindEvents();
                this.loadScenario('residential');
                this.loop();
            }
            destroy() { this.isRunning = false; window.removeEventListener('keydown', this.keyHandler); }
            resize() { const c = document.getElementById('canvas-container'); this.canvas.width = c.clientWidth; this.canvas.height = c.clientHeight; if (this.objects.length === 0 && this.historyStep === -1) { this.offsetX = this.canvas.width / 2; this.offsetY = this.canvas.height / 2; } }
            saveState() { if (this.historyStep < this.history.length - 1) this.history = this.history.slice(0, this.historyStep + 1); this.history.push(JSON.stringify({ objects: this.objects, wires: this.wires })); this.historyStep++; if (this.history.length > 50) { this.history.shift(); this.historyStep--; } this.renderLayers(); this.updateUI(); }
            undo() { if (this.historyStep > 0) { this.historyStep--; this.restoreState(); } }
            redo() { if (this.historyStep < this.history.length - 1) { this.historyStep++; this.restoreState(); } }
            restoreState() { const s = JSON.parse(this.history[this.historyStep]); this.objects = s.objects; this.wires = s.wires; this.selectedObjectId = null; this.updateStats(); this.renderLayers(); this.updateUI(); }
            copy() { if (this.selectedObjectId) { const o = this.objects.find(x => x.id === this.selectedObjectId); if (o) this.clipboard = JSON.parse(JSON.stringify(o)); } }
            paste() { if (this.clipboard) { const n = JSON.parse(JSON.stringify(this.clipboard)); n.id = Math.random().toString(36).slice(2); n.x += 1; n.y += 1; this.objects.push(n); this.selectedObjectId = n.id; this.saveState(); this.updateStats(); } }
            setSunTime(val) { this.sunTime = parseFloat(val); const h = Math.floor(this.sunTime), m = Math.floor((this.sunTime % 1) * 60); document.getElementById('time-display').innerText = `${h > 12 ? h - 12 : (h === 0 ? 12 : h)}:${m.toString().padStart(2, '0')} ${h >= 12 ? 'PM' : 'AM'}`; }
            toggleCableMode() { this.cableMode = this.cableMode === 'straight' ? 'ortho' : 'straight'; document.getElementById('btn-cable-mode').innerHTML = this.cableMode === 'straight' ? '<i class="fa-solid fa-bezier-curve"></i> Straight' : '<i class="fa-solid fa-grip-lines"></i> Bent'; }
            toggleGrid() { this.showGrid = !this.showGrid; document.getElementById('btn-grid-toggle').classList.toggle('bg-blue-600'); }
            setOrientation(val) { this.orientation = parseInt(val); document.getElementById('orient-disp').innerText = this.orientation + '°'; document.getElementById('compass-icon').style.transform = `rotate(${this.orientation}deg)`; }

            toggleTheme(mode) {
                if (mode === 'dark') {
                    COLORS = { grid: '#374151', bg: '#1f2937', wire_dc: '#ef4444', wire_ac: '#eab308', earth: '#16a34a', roof: '#6b7280', tinshed: '#93c5fd', obstacle: 'rgba(239, 68, 68, 0.6)', shadow: 'rgba(0, 0, 0, 0.5)', highlight: 'rgba(59, 130, 246, 0.4)', tree: 'rgba(22, 163, 74, 0.8)', building: '#475569' };
                    document.body.classList.add('bg-gray-900', 'text-gray-100'); document.body.classList.remove('bg-gray-100', 'text-gray-900', 'sepia');
                } else if (mode === 'light') {
                    COLORS = { grid: '#e5e7eb', bg: '#f9fafb', wire_dc: '#dc2626', wire_ac: '#d97706', earth: '#15803d', roof: '#9ca3af', tinshed: '#bfdbfe', obstacle: 'rgba(239, 68, 68, 0.4)', shadow: 'rgba(0, 0, 0, 0.2)', highlight: 'rgba(59, 130, 246, 0.4)', tree: 'rgba(22, 163, 74, 0.6)', building: '#64748b' };
                    document.body.classList.add('bg-gray-100', 'text-gray-900'); document.body.classList.remove('bg-gray-900', 'text-gray-100', 'sepia');
                } else if (mode === 'sepia') {
                    COLORS = { grid: '#d6cbb8', bg: '#f5f0e6', wire_dc: '#b91c1c', wire_ac: '#b45309', earth: '#15803d', roof: '#a8a29e', tinshed: '#dbeafe', obstacle: 'rgba(185, 28, 28, 0.4)', shadow: 'rgba(66, 32, 6, 0.2)', highlight: 'rgba(234, 179, 8, 0.4)', tree: 'rgba(21, 128, 61, 0.6)', building: '#78716c' };
                    document.body.classList.add('bg-[#f5f0e6]', 'text-[#422006]', 'sepia'); document.body.classList.remove('bg-gray-900', 'text-gray-100', 'bg-gray-100', 'text-gray-900');
                }
                this.loop();
            }

            togglePlayback() {
                this.isPlaying = !this.isPlaying;
                const btn = document.getElementById('btn-play');
                btn.innerHTML = this.isPlaying ? '<i class="fa-solid fa-pause"></i>' : '<i class="fa-solid fa-play"></i>';
                if (this.isPlaying) {
                    this.lastFrameTime = performance.now();
                    requestAnimationFrame(this.updatePlayback.bind(this));
                }
            }

            setSpeed(val) { this.playbackSpeed = parseInt(val); }
            setSimMonth(val) { this.simMonth = parseInt(val); }
            resetSimulation() {
                this.isPlaying = false;
                document.getElementById('btn-play').innerHTML = '<i class="fa-solid fa-play"></i>';
                this.sunTime = 6; this.setSunTime(6);
                this.simDayGen = 0; this.simTotalGen = 0;
                this.simTotalImport = 0; this.simTotalExport = 0;
                document.getElementById('sim-day-gen').innerText = "0";
                document.getElementById('sim-total-gen').innerText = "0";
                document.getElementById('sim-power').innerText = "0 kW";
                this.updateUI(); // Reset meter readings in UI
            }

            async searchLocation() {
                const apiKey = document.getElementById('map-api-key').value;
                const query = document.getElementById('map-search-query').value;

                if (!apiKey) { alert("Please enter API Key first"); return; }
                if (!query) { alert("Please enter a location to search"); return; }

                try {
                    const url = `https://maps.googleapis.com/maps/api/geocode/json?address=${encodeURIComponent(query)}&key=${apiKey}`;
                    const resp = await fetch(url);
                    const data = await resp.json();

                    if (data.status === 'OK' && data.results.length > 0) {
                        const loc = data.results[0].geometry.location;
                        document.getElementById('input-lat').value = loc.lat.toFixed(4);
                        document.getElementById('input-lon').value = loc.lng.toFixed(4);
                        alert(`Found: ${data.results[0].formatted_address}`);
                    } else {
                        alert("Location not found: " + data.status);
                    }
                } catch (e) {
                    console.error(e);
                    alert("Search failed. Check API Key and Internet.");
                }
            }

            async importBuildings() {
                const lat = parseFloat(document.getElementById('input-lat').value);
                const lon = parseFloat(document.getElementById('input-lon').value);
                const zoom = parseInt(document.getElementById('map-zoom').value) || 20;

                if (!lat || !lon) { alert("Please set location first."); return; }

                // Calculate Bounding Box (approx 200m radius)
                // 1 deg lat ~ 111km. 0.002 deg ~ 222m
                const radius = 0.002;
                const s = lat - radius;
                const w = lon - radius;
                const n = lat + radius;
                const e = lon + radius;

                const query = `[out:json];(way["building"](${s},${w},${n},${e}););out body;>;out skel qt;`;
                const url = `https://overpass-api.de/api/interpreter?data=${encodeURIComponent(query)}`;

                try {
                    alert("Fetching building data from OpenStreetMap...");
                    const resp = await fetch(url);
                    const data = await resp.json();

                    if (!data.elements || data.elements.length === 0) {
                        alert("No buildings found in this area.");
                        return;
                    }

                    // Process Nodes
                    const nodes = {};
                    data.elements.forEach(el => {
                        if (el.type === 'node') nodes[el.id] = { lat: el.lat, lon: el.lon };
                    });

                    // Process Ways (Buildings)
                    let count = 0;
                    data.elements.forEach(el => {
                        if (el.type === 'way' && el.tags && el.tags.building) {
                            // Convert nodes to world coords
                            // Center of world is (lat, lon) -> (0, 0) offset by mapOffset?
                            // World 0,0 is at screen center if no offset.
                            // Let's assume World 0,0 corresponds to the 'lat, lon' input.

                            // Meters per degree
                            const latMeters = 111320;
                            const lonMeters = 40075000 * Math.cos(lat * Math.PI / 180) / 360;

                            // Calculate bounds of the building to create a rect
                            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;

                            el.nodes.forEach(nid => {
                                const node = nodes[nid];
                                if (node) {
                                    // Delta from center in meters
                                    const dy = -(node.lat - lat) * latMeters; // Y is down in canvas, Lat is up. So invert.
                                    const dx = (node.lon - lon) * lonMeters;

                                    if (dx < minX) minX = dx;
                                    if (dy < minY) minY = dy;
                                    if (dx > maxX) maxX = dx;
                                    if (dy > maxY) maxY = dy;
                                }
                            });

                            if (minX !== Infinity) {
                                const width = maxX - minX;
                                const height = maxY - minY;

                                // Estimate Height
                                let levels = 1;
                                if (el.tags['building:levels']) levels = parseInt(el.tags['building:levels']);
                                else if (el.tags.height) levels = parseFloat(el.tags.height) / 3;
                                const h_z = levels * 3; // 3m per floor

                                // Create Object
                                const id = 'bldg_' + el.id;
                                // Check if exists
                                if (!this.objects.find(o => o.id === id)) {
                                    this.objects.push({
                                        id: id,
                                        type: 'structure', // Use structure for buildings
                                        subtype: 'building',
                                        x: minX, // Meters, relative to center (0,0)
                                        y: minY,
                                        w: width, // Meters
                                        h: height,
                                        h_z: h_z,
                                        color: COLORS.building,
                                        rotation: 0
                                    });
                                    count++;
                                }
                            }
                        }
                    });

                    // Center View on (0,0)
                    this.offsetX = this.canvas.width / 2;
                    this.offsetY = this.canvas.height / 2;

                    this.saveState();
                    this.renderLayers();
                    document.getElementById('map-modal').classList.add('hidden');
                    alert(`Imported ${count} buildings! View centered.`);

                } catch (e) {
                    console.error(e);
                    alert("Import failed. Check internet.");
                }
            }

            loadMapOverlay() {
                const apiKey = document.getElementById('map-api-key').value;
                if (!apiKey) { alert("Please enter a Google Maps API Key"); return; }

                const lat = document.getElementById('input-lat').value;
                const lon = document.getElementById('input-lon').value;
                const zoom = document.getElementById('map-zoom').value;

                // Calculate map dimensions based on canvas size
                // Static Maps API max size is 640x640 for free tier usually, but let's try requesting larger or scaling
                // Better: Use a fixed size and scale canvas to match? Or just center it.
                const w = 640; const h = 640;

                const url = `https://maps.googleapis.com/maps/api/staticmap?center=${lat},${lon}&zoom=${zoom}&size=${w}x${h}&maptype=satellite&key=${apiKey}`;

                const img = new Image();
                img.crossOrigin = "Anonymous";
                img.onload = () => {
                    this.mapImage = img;
                    this.mapOffset = { x: 0, y: 0 }; // Center map at 0,0 world coords?
                    // Let's align map center to world 0,0
                    // Map covers world area based on zoom.
                    // At zoom 20, 1 pixel is approx 0.149 meters at equator.
                    // Meters/pixel = 156543.03392 * cos(lat * PI/180) / 2^zoom
                    const metersPerPixel = 156543.03392 * Math.cos(lat * Math.PI / 180) / Math.pow(2, zoom);
                    this.mapScale = 1 / metersPerPixel; // pixels per meter (world scale is pixels per meter)
                    // Actually our this.scale is pixels per meter (25 default).
                    // We need to draw the map image such that it matches real world dimensions.
                    // Image width in meters = w * metersPerPixel.
                    // We draw image at x,y with width,height in world coords?
                    // No, we draw in screen coords.
                    // Let's store map properties and draw in loop.
                    this.mapMetersPerPixel = metersPerPixel;
                    document.getElementById('map-modal').classList.add('hidden');
                    alert("Map Loaded! Aligning grid to map...");
                };
                img.onerror = () => alert("Failed to load map. Check API Key and Internet.");
                img.src = url;
            }

            async updatePlayback(timestamp) {
                if (!this.isPlaying) return;
                if (!this.lastFrameTime) this.lastFrameTime = timestamp;
                const dt = (timestamp - this.lastFrameTime) / 1000;
                this.lastFrameTime = timestamp;

                const speed = parseInt(document.getElementById('sim-speed').value) || 10;
                const dt_hours = (dt * speed) / 60; // Real seconds to Sim hours
                this.sunTime += dt_hours;

                if (this.sunTime >= 24) {
                    this.sunTime -= 24;
                    this.simDayGen = 0; // Reset day gen at midnight
                }

                this.setSunTime(this.sunTime);

                // --- Realistic Solar Calculation ---
                const lat = parseFloat(document.getElementById('input-lat').value) || 28.6;
                const lon = parseFloat(document.getElementById('input-lon').value) || 77.2;

                // Create date object for current sim time (assume current year/month/day for now)
                const now = new Date();
                now.setMonth(this.simMonth);
                now.setHours(Math.floor(this.sunTime));
                now.setMinutes((this.sunTime % 1) * 60);

                // 1. Sun Position
                const sunPos = SunCalc.getPosition(now, lat, lon);
                const elevation = sunPos.altitude; // Radians
                const azimuth = sunPos.azimuth; // Radians

                // 2. Weather & Irradiance
                let irradiance = 0;
                let cloudCover = 0;

                // Try fetch weather
                const weatherData = await weatherService.getWeather(lat, lon, now);

                if (weatherData) {
                    // Find closest hour index
                    const hourIndex = Math.floor(this.sunTime);
                    if (weatherData.direct_normal_irradiance && weatherData.direct_normal_irradiance[hourIndex] !== undefined) {
                        const dni = weatherData.direct_normal_irradiance[hourIndex];
                        const diffuse = weatherData.diffuse_radiation[hourIndex];
                        cloudCover = weatherData.cloudcover[hourIndex];

                        // Simple Plane of Array (POA) Irradiance Model
                        // POA = DNI * cos(AOI) + Diffuse
                        // AOI (Angle of Incidence) depends on panel tilt/azimuth vs sun.
                        // Simplified: assume panels are flat or optimal tilt.
                        // Let's use a simplified factor based on elevation for now + cloud effect
                        irradiance = (dni * Math.sin(elevation)) + diffuse;
                    }
                } else {
                    // Fallback: Clear Sky Model
                    if (elevation > 0) {
                        irradiance = 1000 * Math.sin(elevation); // Max 1000 W/m2
                        // Add random cloud noise
                        cloudCover = Math.random() * 20; // 0-20% random clouds
                        irradiance *= (1 - cloudCover / 100);
                    }
                }

                if (irradiance < 0) irradiance = 0;

                // 3. Calculate Power
                const panels = this.objects.filter(o => o.type === 'panel');
                const totalCap = panels.reduce((sum, p) => sum + p.watts, 0); // Watts

                // Shadow Loss
                const shadowLoss = this.calculateShadowLoss();

                // Final Power Output
                const efficiency = 0.18; // Panel efficiency (approx) or use rated watts directly
                // Rated Watts is at STC (1000 W/m2). So Output = Rated * (Irradiance / 1000)
                let powerOutput = totalCap * (irradiance / 1000) * (1 - shadowLoss);

                if (powerOutput < 0) powerOutput = 0;

                // Accumulate Energy
                const gen_kWh = (powerOutput / 1000) * dt_hours;
                this.simDayGen += gen_kWh;
                this.simTotalGen += (gen_kWh / 1000); // MWh

                // Load Logic
                const baseLoad = parseFloat(document.getElementById('input-load').value) || 500;
                const loadBoxes = this.objects.filter(o => o.type === 'load');
                const boxLoad = loadBoxes.reduce((sum, b) => sum + (b.units || 500), 0);
                const totalMonthlyLoad = baseLoad + boxLoad;
                const hourlyLoad = totalMonthlyLoad / (30 * 24); // Average hourly load
                const load_kWh = hourlyLoad * dt_hours;

                // Net Meter
                if (gen_kWh > load_kWh) {
                    this.simTotalExport += (gen_kWh - load_kWh);
                } else {
                    this.simTotalImport += (load_kWh - gen_kWh);
                }

                // Update UI
                document.getElementById('sim-power').innerText = (powerOutput / 1000).toFixed(2) + " kW";
                document.getElementById('sim-day-gen').innerText = this.simDayGen.toFixed(1);
                document.getElementById('sim-total-gen').innerText = this.simTotalGen.toFixed(3);

                // Weather UI
                const weatherIcon = cloudCover > 50 ? '<i class="fa-solid fa-cloud text-gray-400"></i>' : '<i class="fa-solid fa-sun text-yellow-400"></i>';
                document.getElementById('sim-weather-icon').innerHTML = weatherIcon;
                document.getElementById('sim-irradiance').innerText = Math.round(irradiance) + " W/m²";

                // Update Meters if selected
                if (this.selectedObjectId) {
                    const obj = this.objects.find(o => o.id === this.selectedObjectId);
                    if (obj && (obj.subtype === 'meter_gross' || obj.subtype === 'meter_net')) {
                        this.updateUI();
                    }
                }

                if (this.isPlaying) {
                    requestAnimationFrame(this.updatePlayback.bind(this));
                }
            }

            calculateYearlyShadowLoss() {
                // Sample 12 months, 7 AM to 5 PM, every hour
                const panels = this.objects.filter(o => o.type === 'panel');
                if (panels.length === 0) return 0;

                let totalPotential = 0;
                let totalLoss = 0;

                // Save current state
                const savedTime = this.sunTime;

                for (let m = 0; m < 12; m++) {
                    // Approximate sun path shift for seasons (simplified)
                    // In reality, declination changes. Here we simulate by shifting "effective" time or angle?
                    // For MVP, we'll keep the path same but vary intensity/length? 
                    // Actually, let's just use the current path but sample across the day.
                    // To do it properly, we need declination.
                    // Let's implement a simplified declination shift.
                    const declination = -23.45 * Math.cos((360 / 365) * (m + 10) * Math.PI / 180);
                    // This affects elevation. 

                    for (let h = 7; h <= 17; h += 1) {
                        this.sunTime = h;
                        // Recalculate shadow vector with declination effect (simplified: just modify elevation slightly)
                        // Ideally we update getShadowVector to take declination. 
                        // For now, let's just use the standard path as "Equinox" and maybe vary length?
                        // Let's stick to the standard path for now to ensure stability, but sample hourly.

                        const v = this.getShadowVector();
                        if (!v) continue;

                        const elevation = Math.sin(((h - 6) / 12) * Math.PI);
                        const potential = panels.reduce((sum, p) => sum + p.watts, 0) * elevation;

                        // Calculate shadow coverage
                        panels.forEach(p => {
                            let shadedPoints = 0;
                            const points = [
                                { x: p.x + 0.1, y: p.y + 0.1 }, // tl (inset slightly)
                                { x: p.x + p.w - 0.1, y: p.y + 0.1 }, // tr
                                { x: p.x + 0.1, y: p.y + p.h - 0.1 }, // bl
                                { x: p.x + p.w - 0.1, y: p.y + p.h - 0.1 }, // br
                                { x: p.x + p.w / 2, y: p.y + p.h / 2 } // center
                            ];

                            points.forEach(pt => {
                                const isShaded = this.objects.some(o => {
                                    if (o.id === p.id) return false;
                                    if (o.h_z <= p.h_z) return false; // Only higher objects cast shadow

                                    const dx = v.x * (o.h_z - p.h_z);
                                    const dy = v.y * (o.h_z - p.h_z);
                                    const sx = o.x + dx; const sy = o.y + dy;

                                    // Check shifted rect
                                    return (pt.x >= sx && pt.x <= sx + o.w && pt.y >= sy && pt.y <= sy + o.h);
                                });
                                if (isShaded) shadedPoints++;
                            });

                            const coverage = shadedPoints / 5;
                            const loss = coverage * potential;
                            totalPotential += potential;
                            totalLoss += loss;
                        });
                    }
                }

                this.sunTime = savedTime; // Restore
                return totalPotential > 0 ? (totalLoss / totalPotential) : 0;
            }

            isPointInShadow(px, py, ph, v) {
                return this.objects.some(o => {
                    if (o.h_z <= ph) return false;
                    const dx = v.x * (o.h_z - ph);
                    const dy = v.y * (o.h_z - ph);
                    // Check if point (px, py) is inside the shadow cast by o
                    // Shadow is a parallelogram formed by o and o+d
                    // Simple check: project point back by -d, see if it falls in o
                    // Back projection: 
                    // If point P is in shadow, then P - k*d must be in O for some 0 < k < 1?
                    // Actually, simpler: The shadow of O at height ph is O shifted by d.
                    // So we check if P is inside rectangle O shifted by d.
                    const sx = o.x + dx; const sy = o.y + dy;
                    return (px >= sx && px <= sx + o.w && py >= sy && py <= sy + o.h);
                });
            }

            // --- CUSTOM COMPONENT ---
            openCreateModal(type) {
                document.getElementById('create-modal').classList.remove('hidden');
                document.getElementById('new-type').value = type;
                document.getElementById('new-cost').value = type === 'panel' ? 18000 : 60000;
                document.getElementById('new-cap').value = type === 'panel' ? 550 : 5;
            }

            addCustomComponent() {
                const name = document.getElementById('new-name').value || "Custom";
                const type = document.getElementById('new-type').value;
                const color = document.getElementById('new-color').value;
                const w = parseFloat(document.getElementById('new-w').value) || 1;
                const h = parseFloat(document.getElementById('new-h').value) || 1;
                const cap = parseFloat(document.getElementById('new-cap').value) || 0;
                const cost = parseFloat(document.getElementById('new-cost').value) || 0;
                const id = 'cust_' + Date.now();
                const def = { type, w, h, cost, color, h_z: 0.5 };
                if (type === 'panel') { def.watts = cap; def.structure_h = 0.5; }
                else if (type === 'inverter') { def.capKw = cap; def.subtype = 'string'; }
                else if (type === 'battery') { def.capKwh = cap; def.h_z = 1; }
                COMPONENTS[id] = def;
                const container = type === 'panel' ? document.getElementById('tools-panel-list') : document.getElementById('tools-elec-list');
                const div = document.createElement('div');
                div.onclick = () => app.setTool(id);
                div.className = "sidebar-item p-2 rounded border border-gray-200 cursor-pointer flex items-center gap-3";
                div.innerHTML = `<div class="w-6 h-6 rounded border" style="background:${color}"></div><div><div class="font-bold text-sm">${name}</div><div class="text-[10px] text-gray-500">₹${cost}</div></div>`;
                container.appendChild(div);
                document.getElementById('create-modal').classList.add('hidden');
            }

            // --- JSON Load/Save ---
            saveProject() {
                const data = { version: "4.5", date: new Date().toISOString(), objects: this.objects, wires: this.wires, settings: { load: document.getElementById('input-load').value, rate: document.getElementById('input-rate').value } };
                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a'); a.href = url; a.download = 'solar-project.json'; a.click(); URL.revokeObjectURL(url);
            }
            loadProject(input) {
                const file = input.files[0]; if (!file) return;
                const reader = new FileReader();
                reader.onload = (e) => {
                    try { const data = JSON.parse(e.target.result); if (data.objects && data.wires) { this.objects = data.objects; this.wires = data.wires; if (data.settings) { document.getElementById('input-load').value = data.settings.load || 500; document.getElementById('input-rate').value = data.settings.rate || 8.5; } this.saveState(); this.updateStats(); alert("Project Loaded Successfully"); } else { alert("Invalid file format"); } } catch (err) { alert("Error loading file: " + err); }
                }; reader.readAsText(file);
            }

            getStructureBelow(obj) {
                const cx = obj.x + obj.w / 2; const cy = obj.y + obj.h / 2;
                const structures = this.objects.filter(o => (o.type === 'structure' || o.type === 'obstacle') && o.id !== obj.id);
                structures.sort((a, b) => b.h_z - a.h_z);
                for (let s of structures) {
                    if (cx >= s.x - 0.05 && cx <= s.x + s.w + 0.05 && cy >= s.y - 0.05 && cy <= s.y + s.h + 0.05) return s;
                }
                return null;
            }

            updateObjectZ(obj) {
                const structure = this.getStructureBelow(obj);
                const baseZ = structure ? structure.h_z : 0;
                if (obj.type === 'panel' || ['inverter', 'bos', 'grid', 'load', 'battery', 'safety', 'obstacle', 'structure'].includes(obj.type)) {
                    if (obj.relative_h === undefined) obj.relative_h = (obj.h_z - baseZ) || 0.5;
                    obj.h_z = baseZ + obj.relative_h;
                }
            }
            setHeight(val) {
                if (!this.selectedObjectId) return;
                const relativeH = parseFloat(val);
                const obj = this.objects.find(o => o.id === this.selectedObjectId);
                if (obj) {
                    obj.relative_h = relativeH;
                    this.updateObjectZ(obj);
                    // If this object supports others, update them too
                    if (obj.type === 'structure' || obj.type === 'obstacle') {
                        this.objects.forEach(child => { if (child.id !== obj.id) this.updateObjectZ(child); });
                    }
                    if (obj.label && obj.label.includes('(')) obj.label = obj.label.split('(')[0].trim() + ` (${obj.h_z.toFixed(1)}m)`;
                    this.renderLayers(); this.updateUI(); this.saveState();
                }
            }
            setHeightFromInput(val, unit) { let m = parseFloat(val); if (isNaN(m)) return; if (unit === 'ft') m = m * 0.3048; this.setHeight(m.toFixed(1)); }
            rotateSelection() { if (!this.selectedObjectId) return; const obj = this.objects.find(o => o.id === this.selectedObjectId); if (obj) { const temp = obj.w; obj.w = obj.h; obj.h = temp; this.saveState(); } }
            fillSelection(panelType) {
                if (!this.selectedObjectId) return;
                const structure = this.objects.find(o => o.id === this.selectedObjectId);
                const def = COMPONENTS[panelType];
                if (structure && structure.type === 'structure' && def) {
                    const margin = 0.2; const startX = structure.x + margin; const startY = structure.y + margin; const endX = structure.x + structure.w - margin; const endY = structure.y + structure.h - margin;
                    const relative_h = 0.5; const h_z = structure.h_z + relative_h;
                    let count = 0;
                    for (let y = startY; y + def.h < endY; y += def.h + 0.05) {
                        for (let x = startX; x + def.w < endX; x += def.w + 0.05) {
                            const hit = this.objects.some(o => {
                                if (o.id === structure.id) return false;
                                return (x < o.x + o.w && x + def.w > o.x && y < o.y + o.h && y + def.h > o.y);
                            });
                            if (!hit) { this.objects.push({ ...def, id: Math.random().toString(36).slice(2), x, y, h_z, relative_h }); count++; }
                        }
                    }
                    if (count > 0) { this.saveState(); this.updateStats(); alert(`Filled with ${count} panels!`); } else { alert("No space to fit panels!"); }
                } else { alert("Please select a structure (Roof/Ground) first."); }
            }
            setMode(m) { this.mode = m; this.selectedToolId = null; this.drawType = null; this.selectedObjectId = null; this.arrayStart = null; this.updateUI(); }
            setTool(id) { this.mode = 'place'; this.selectedToolId = id; this.updateUI(); }
            setDrawMode(type) { this.mode = 'draw_rect'; this.drawType = type; this.updateUI(); }

            closeRightPanel() {
                document.getElementById('right-panel').classList.add('translate-x-full');
                this.selectedObjectId = null;
                this.updateUI();
            }

            updateUI() {
                try {
                    document.querySelectorAll('.sidebar-item').forEach(el => el.classList.remove('selected'));
                    if (this.mode === 'draw_rect') document.getElementById('btn-draw_' + this.drawType)?.classList.add('selected');
                    else if (this.mode !== 'place') document.getElementById('btn-' + this.mode)?.classList.add('selected');
                    else if (this.selectedToolId) document.getElementById('tool-' + this.selectedToolId)?.classList.add('selected');

                    const rp = document.getElementById('right-panel');
                    const rc = document.getElementById('right-panel-content');

                    if (!rp || !rc) return;

                    if (this.selectedObjectId) {
                        const obj = this.objects.find(o => o.id === this.selectedObjectId);
                        if (obj) {
                            rp.classList.remove('translate-x-full');
                            const struct = this.getStructureBelow(obj);
                            let baseZ = 0; let displayVal = obj.h_z;
                            let baseText = "Absolute Height";

                            if (obj.subType === 'ground') {
                                // For ground, h_z is absolute
                            } else {
                                baseZ = struct ? struct.h_z : 0;
                                const baseName = struct ? (struct.label || struct.subType) : "Ground";
                                baseText = `On ${baseName} (${baseZ}m)`;
                                displayVal = obj.relative_h;
                            }

                            // Ensure displayVal is a number
                            if (isNaN(displayVal)) displayVal = 0;

                            const m = parseFloat(displayVal).toFixed(1);
                            const ft = (m * 3.28084).toFixed(1);

                            // Safely update inputs if they exist
                            const slider = document.getElementById('height-slider');
                            const inputM = document.getElementById('input-h-m');
                            const inputFt = document.getElementById('input-h-ft');
                            if (slider) slider.value = m;
                            if (inputM) inputM.value = m;
                            if (inputFt) inputFt.value = ft;

                            let details = `
                            <div class="space-y-4">
                                <div>
                                    <label class="block text-[10px] font-bold text-gray-500 uppercase">Type</label>
                                    <div class="font-bold text-lg text-gray-800">${obj.label || obj.subType || obj.type}</div>
                                    <div class="text-xs text-gray-400 font-mono">ID: ${obj.id.substring(0, 8)}</div>
                                </div>
                                
                                <div class="grid grid-cols-2 gap-2">
                                    <div>
                                        <label class="block text-[10px] font-bold text-gray-500 uppercase">Width (m)</label>
                                        <input type="number" value="${obj.w.toFixed(2)}" class="w-full border rounded p-1 text-sm bg-gray-50" disabled>
                                    </div>
                                    <div>
                                        <label class="block text-[10px] font-bold text-gray-500 uppercase">Height (m)</label>
                                        <input type="number" value="${obj.h.toFixed(2)}" class="w-full border rounded p-1 text-sm bg-gray-50" disabled>
                                    </div>
                                </div>
                        `;
                            if (obj.subtype === 'meter_gross') {
                                details += `<div class="mb-2 p-2 bg-green-50 rounded border border-green-200">
                        <div class="text-[10px] font-bold text-green-800 uppercase mb-1">Solar Generation</div>
                        <div class="text-lg font-mono text-green-600">${(this.simTotalGen || 0).toFixed(2)} kWh</div>
                    </div>`;
                            }
                            if (obj.subtype === 'meter_net') {
                                const net = (this.simTotalExport || 0) - (this.simTotalImport || 0);
                                details += `<div class="mb-2 p-2 bg-blue-50 rounded border border-blue-200 space-y-2">
                        <div><div class="text-[10px] font-bold text-blue-800 uppercase">Import (Grid to Home)</div><div class="font-mono text-red-600">${(this.simTotalImport || 0).toFixed(2)} kWh</div></div>
                        <div><div class="text-[10px] font-bold text-blue-800 uppercase">Export (Solar to Grid)</div><div class="font-mono text-green-600">${(this.simTotalExport || 0).toFixed(2)} kWh</div></div>
                        <div class="border-t border-blue-200 pt-1"><div class="text-[10px] font-bold text-blue-800 uppercase">Net Reading</div><div class="font-mono ${net >= 0 ? 'text-green-600' : 'text-red-600'}">${net.toFixed(2)} kWh</div></div>
                    </div>`;
                            }
                            details += `
                                <div>
                                    <div class="flex justify-between">
                                        <label class="text-[10px] text-gray-500 uppercase font-bold">Elevation (Z)</label>
                                        <span class="text-[9px] text-blue-600 font-bold">${baseText}</span>
                                    </div>
                                    <div class="flex gap-2 items-center mt-1">
                                        <input type="number" id="input-h-m" class="unit-input" value="${m}" 
                                            onchange="app.setHeightFromInput(this.value, 'm')"> <span class="text-xs text-gray-500">m</span>
                                    </div>
                                    <input type="range" min="0" max="50" step="0.1" value="${displayVal}" id="height-slider"
                                        oninput="app.setHeight(this.value)" class="w-full mt-1">
                                </div>
                        `;

                            if (obj.type === 'panel') {
                                details += `
                                <div class="p-2 bg-blue-50 rounded border border-blue-100">
                                    <label class="block text-[10px] font-bold text-blue-800 uppercase">Specs</label>
                                    <div class="text-sm font-bold text-blue-900">${obj.watts} Watts</div>
                                    <div class="text-xs text-blue-700">₹${obj.cost}</div>
                                </div>
                            `;
                            }

                            if (obj.type === 'structure') {
                                details += `
                                <div class="mt-3 border-t border-gray-200 pt-2">
                                    <label class="text-[10px] font-bold text-blue-800 uppercase">Auto-Fill Panels</label>
                                    <div class="grid grid-cols-2 gap-2 mt-1">
                                        <button onclick="app.fillSelection('panel_585')" class="bg-blue-600 hover:bg-blue-700 text-white text-xs py-1 px-2 rounded">Fill 585W</button>
                                        <button onclick="app.fillSelection('panel_730')" class="bg-blue-800 hover:bg-blue-900 text-white text-xs py-1 px-2 rounded">Fill 730W</button>
                                    </div>
                                </div>
                            `;
                            }

                            if (obj.subtype === 'acdb' || obj.subtype === 'lt_panel') {
                                details += `
                                <div class="mt-3 border-t border-gray-200 pt-2">
                                    <label class="text-[10px] font-bold text-gray-500 uppercase">Switch Status</label>
                                    <div class="flex items-center gap-2 mt-1">
                                        <button onclick="app.toggleSwitch('${obj.id}')" class="flex-1 py-1 px-2 rounded text-xs font-bold ${obj.isOn !== false ? 'bg-green-100 text-green-700' : 'bg-red-100 text-red-700'}">
                                            ${obj.isOn !== false ? '<i class="fa-solid fa-toggle-on text-lg"></i> ON' : '<i class="fa-solid fa-toggle-off text-lg"></i> OFF'}
                                        </button>
                                    </div>
                                </div>
                            `;
                            }

                            if (obj.type === 'load') {
                                details += `
                                <div class="mt-3 border-t border-gray-200 pt-2">
                                    <label class="text-[10px] font-bold text-orange-800 uppercase">Consumption</label>
                                    <div class="mt-1">
                                        <label class="text-[9px] text-gray-500">Monthly Units</label>
                                        <input type="number" value="${obj.units || 500}" onchange="app.setLoadUnits('${obj.id}', this.value)" class="w-full border rounded p-1 text-sm">
                                    </div>
                                </div>
                            `;
                            }

                            details += `</div>`;
                            rc.innerHTML = details;
                        }
                        document.querySelectorAll('.layer-item').forEach(el => el.classList.remove('active'));
                        document.getElementById('layer-' + this.selectedObjectId)?.classList.add('active');
                    } else {
                        rp.classList.add('translate-x-full');
                        document.querySelectorAll('.layer-item').forEach(el => el.classList.remove('active'));
                    }
                } catch (e) { console.error("UI Update Error:", e); }
            }

            renderLayers() {
                const container = document.getElementById('layers-list');
                container.innerHTML = '';
                const sorted = [...this.objects].sort((a, b) => b.h_z - a.h_z);
                sorted.forEach(o => {
                    const div = document.createElement('div');
                    div.className = 'layer-item p-2 flex justify-between items-center';
                    div.id = 'layer-' + o.id;
                    let icon = 'fa-square';
                    if (o.type === 'panel') icon = 'fa-solar-panel'; if (o.type === 'obstacle') icon = 'fa-tree'; if (o.type === 'structure') icon = 'fa-building';

                    const groupIndicator = o.groupId ? `<i class="fa-solid fa-link text-xs text-blue-400 ml-1" title="Grouped"></i>` : '';

                    div.innerHTML = `
                        <div class="flex items-center gap-2 truncate flex-1">
                            <input type="checkbox" class="layer-check cursor-pointer" value="${o.id}" onclick="event.stopPropagation()">
                            <i class="fa-solid ${icon} text-gray-400 w-4 text-center"></i>
                            <span class="truncate">${o.label || o.subType || 'Object'}</span>
                            ${groupIndicator}
                        </div>
                        <span class="text-xs text-gray-400 ml-2 font-mono">${o.h_z.toFixed(1)}m</span>
                    `;
                    div.onclick = (e) => {
                        if (e.target.type !== 'checkbox') {
                            this.selectedObjectId = o.id; this.updateUI();
                        }
                    };
                    container.appendChild(div);
                });
            }

            groupSelected() {
                const checks = document.querySelectorAll('.layer-check:checked');
                if (checks.length < 2) { alert("Select at least 2 items to group."); return; }
                const groupId = 'grp_' + Date.now();
                checks.forEach(c => {
                    const obj = this.objects.find(o => o.id === c.value);
                    if (obj) obj.groupId = groupId;
                });
                this.renderLayers(); this.saveState();
            }

            ungroupSelected() {
                const checks = document.querySelectorAll('.layer-check:checked');
                if (checks.length === 0) { alert("Select items to ungroup."); return; }
                checks.forEach(c => {
                    const obj = this.objects.find(o => o.id === c.value);
                    if (obj) delete obj.groupId;
                });
                this.renderLayers(); this.saveState();
            }

            toggleSwitch(id) {
                const obj = this.objects.find(o => o.id === id);
                if (obj) {
                    obj.isOn = obj.isOn === false ? true : false;
                    this.saveState(); this.updateUI();
                }
            }
            setLoadUnits(id, val) {
                const obj = this.objects.find(o => o.id === id);
                if (obj) {
                    obj.units = parseFloat(val) || 0;
                    this.saveState();
                }
            }

            loadScenario(type) { this.objects = []; this.wires = []; this.offsetX = this.canvas.width / 2; this.offsetY = this.canvas.height / 2; if (type === 'residential') { this.scale = 30; this.objects.push({ id: 'roof1', type: 'structure', subType: 'roof', x: -6, y: -4, w: 12, h: 8, color: COLORS.roof, h_z: 4, label: 'Roof (4m)', relative_h: 4 }); this.objects.push({ id: 'chimney', type: 'obstacle', x: -2, y: -1, w: 1, h: 1.5, h_z: 6, label: 'Chimney (6m)', relative_h: 2 }); this.objects.push({ id: 'grid', type: 'grid', x: -9, y: 6, w: 1, h: 1, label: 'Grid', h_z: 0 }); } else if (type === 'commercial') { this.scale = 15; this.objects.push({ id: 'ground', type: 'structure', subType: 'ground', x: -25, y: -20, w: 50, h: 40, color: '#3f6212', h_z: 0, label: 'Ground', relative_h: 0 }); this.objects.push({ id: 'bldg', type: 'structure', subType: 'building', x: -10, y: 5, w: 8, h: 6, h_z: 15, label: 'Building (15m)', color: COLORS.building, relative_h: 15 }); this.objects.push({ id: 'bldg2', type: 'structure', subType: 'building', x: -10, y: 15, w: 8, h: 6, h_z: 20, label: 'Tall Bldg (20m)', color: COLORS.building, relative_h: 20 }); this.objects.push({ id: 'grid', type: 'grid', x: -28, y: 0, w: 2, h: 2, label: 'Substation', h_z: 2, relative_h: 2 }); } this.saveState(); this.updateStats(); }
            resetMap() { this.objects = []; this.wires = []; this.saveState(); this.updateStats(); }
            bindEvents() { this.canvas.addEventListener('mousedown', e => this.onDown(e)); this.canvas.addEventListener('mousemove', e => this.onMove(e)); this.canvas.addEventListener('mouseup', e => this.onUp(e)); this.canvas.addEventListener('wheel', e => { this.scale = Math.max(5, Math.min(100, this.scale * (e.deltaY > 0 ? 0.9 : 1.1))); }); this.canvas.addEventListener('contextmenu', e => e.preventDefault()); }
            getWorldPos(e) { const r = this.canvas.getBoundingClientRect(); return { x: (e.clientX - r.left - this.offsetX) / this.scale, y: (e.clientY - r.top - this.offsetY) / this.scale }; }
            getResizeHandle(obj, wPos) { if (!obj) return null; const pad = 0.5; if (Math.abs(wPos.x - obj.x) < pad && Math.abs(wPos.y - obj.y) < pad) return 'tl'; if (Math.abs(wPos.x - (obj.x + obj.w)) < pad && Math.abs(wPos.y - obj.y) < pad) return 'tr'; if (Math.abs(wPos.x - obj.x) < pad && Math.abs(wPos.y - (obj.y + obj.h)) < pad) return 'bl'; if (Math.abs(wPos.x - (obj.x + obj.h)) < pad && Math.abs(wPos.y - (obj.y + obj.h)) < pad) return 'br'; return null; }

            async handleContextAction(action) {
                const { lat, lon } = this.contextPos;
                if (action === 'import_ai') {
                    await this.importWithGemini(lat, lon);
                } else if (action === 'import_osm') {
                    await this.importBuildingAt(lat, lon);
                } else if (action === 'set_origin') {
                    document.getElementById('input-lat').value = lat.toFixed(6);
                    document.getElementById('input-lon').value = lon.toFixed(6);
                    this.offsetX = this.canvas.width / 2;
                    this.offsetY = this.canvas.height / 2;
                    this.renderLayers();
                    alert("Origin Set!");
                }
            }

            async importWithGemini(lat, lon) {
                const mapKey = document.getElementById('map-api-key').value;
                const geminiKey = document.getElementById('gemini-api-key').value;
                const mode = document.getElementById('gemini-mode').value;

                if (!mapKey || !geminiKey) { alert("Please set both Google Maps and Gemini API Keys in Setup."); return; }

                // 1. Fetch Static Map Image
                const zoom = 20;
                const size = 600; // 600x600 pixels
                const mapUrl = `https://maps.googleapis.com/maps/api/staticmap?center=${lat},${lon}&zoom=${zoom}&size=${size}x${size}&maptype=satellite&key=${mapKey}`;

                try {
                    document.body.style.cursor = 'wait';
                    const imgResp = await fetch(mapUrl);
                    const blob = await imgResp.blob();
                    const base64 = await new Promise((resolve) => {
                        const reader = new FileReader();
                        reader.onloadend = () => resolve(reader.result.split(',')[1]);
                        reader.readAsDataURL(blob);
                    });

                    // 2. Call Gemini API
                    const prompt = `Analyze this satellite image. Identify the building at the exact center. Return a JSON object with a 'polygons' array. Each item should have 'type' ('building' or 'obstacle') and 'points' (array of {x, y} where x,y are percentage coordinates 0-100 relative to image width/height). ${mode === 'surroundings' ? 'Include surrounding trees/obstacles.' : 'Ignore surroundings, focus on the main building.'} Output ONLY raw JSON.`;

                    const geminiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${geminiKey}`;
                    const geminiResp = await fetch(geminiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            contents: [{
                                parts: [
                                    { text: prompt },
                                    { inline_data: { mime_type: "image/png", data: base64 } }
                                ]
                            }]
                        })
                    });

                    const geminiData = await geminiResp.json();
                    document.body.style.cursor = 'default';

                    if (!geminiData.candidates || !geminiData.candidates[0].content) {
                        console.error(geminiData);
                        alert("Gemini could not analyze the image.");
                        return;
                    }

                    const text = geminiData.candidates[0].content.parts[0].text;
                    const jsonStr = text.replace(/```json/g, '').replace(/```/g, '').trim();
                    const result = JSON.parse(jsonStr);

                    // 3. Convert to World Objects
                    const metersPerPixel = 156543.03392 * Math.cos(lat * Math.PI / 180) / Math.pow(2, 20);
                    const imgWidthMeters = size * metersPerPixel;
                    const imgHeightMeters = size * metersPerPixel;

                    // Calculate world pos of click (center of image)
                    const centerLat = parseFloat(document.getElementById('input-lat').value);
                    const centerLon = parseFloat(document.getElementById('input-lon').value);
                    const latMeters = 111320;
                    const lonMeters = 40075000 * Math.cos(centerLat * Math.PI / 180) / 360;

                    const dy = -(lat - centerLat) * latMeters;
                    const dx = (lon - centerLon) * lonMeters;

                    let count = 0;
                    if (result.polygons) {
                        result.polygons.forEach(poly => {
                            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                            poly.points.forEach(p => {
                                const xm = (p.x - 50) / 100 * imgWidthMeters;
                                const ym = (p.y - 50) / 100 * imgHeightMeters;
                                if (xm < minX) minX = xm;
                                if (ym < minY) minY = ym;
                                if (xm > maxX) maxX = xm;
                                if (ym > maxY) maxY = ym;
                            });

                            const w = maxX - minX;
                            const h = maxY - minY;
                            const cx = minX + w / 2;
                            const cy = minY + h / 2;

                            const worldX = dx + cx;
                            const worldY = dy + cy;

                            const id = 'ai_' + Math.random().toString(36).substr(2, 9);
                            this.objects.push({
                                id: id,
                                type: poly.type === 'building' ? 'structure' : 'obstacle',
                                subtype: poly.type === 'building' ? 'building' : 'tree',
                                x: worldX - w / 2,
                                y: worldY - h / 2,
                                w: w,
                                h: h,
                                h_z: poly.type === 'building' ? 6 : 4,
                                color: poly.type === 'building' ? COLORS.building : COLORS.tree,
                                rotation: 0
                            });
                            count++;
                        });

                        this.saveState();
                        this.renderLayers();
                        alert(`AI Imported ${count} objects!`);
                    }

                } catch (e) {
                    console.error(e);
                    document.body.style.cursor = 'default';
                    alert("AI Import Failed: " + e.message);
                }
            }

            async importBuildingAt(lat, lon) {
                const radius = 10; // meters
                const query = `[out:json];(way["building"](around:${radius},${lat},${lon}););out body;>;out skel qt;`;
                const url = `https://overpass-api.de/api/interpreter?data=${encodeURIComponent(query)}`;

                try {
                    document.body.style.cursor = 'wait';
                    const resp = await fetch(url);
                    const data = await resp.json();
                    document.body.style.cursor = 'default';

                    if (!data.elements || data.elements.length === 0) {
                        alert("No building found at this location.");
                        return;
                    }

                    const nodes = {};
                    data.elements.forEach(el => {
                        if (el.type === 'node') nodes[el.id] = { lat: el.lat, lon: el.lon };
                    });

                    let imported = false;
                    const centerLat = parseFloat(document.getElementById('input-lat').value);
                    const centerLon = parseFloat(document.getElementById('input-lon').value);
                    const latMeters = 111320;
                    const lonMeters = 40075000 * Math.cos(centerLat * Math.PI / 180) / 360;

                    data.elements.forEach(el => {
                        if (el.type === 'way' && el.tags && el.tags.building) {
                            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                            el.nodes.forEach(nid => {
                                const node = nodes[nid];
                                if (node) {
                                    const dy = -(node.lat - centerLat) * latMeters;
                                    const dx = (node.lon - centerLon) * lonMeters;
                                    if (dx < minX) minX = dx;
                                    if (dy < minY) minY = dy;
                                    if (dx > maxX) maxX = dx;
                                    if (dy > maxY) maxY = dy;
                                }
                            });

                            if (minX !== Infinity) {
                                const width = maxX - minX;
                                const height = maxY - minY;
                                let levels = 1;
                                if (el.tags['building:levels']) levels = parseInt(el.tags['building:levels']);
                                else if (el.tags.height) levels = parseFloat(el.tags.height) / 3;
                                const h_z = levels * 3;

                                const id = 'bldg_' + el.id;
                                if (!this.objects.find(o => o.id === id)) {
                                    this.objects.push({
                                        id: id,
                                        type: 'structure',
                                        subtype: 'building',
                                        x: minX,
                                        y: minY,
                                        w: width,
                                        h: height,
                                        h_z: h_z,
                                        color: COLORS.building,
                                        rotation: 0
                                    });
                                    imported = true;
                                } else {
                                    // alert("Building already imported."); // Removed this alert as it can be annoying
                                    imported = true;
                                }
                            }
                        }
                    });

                    if (imported) {
                        this.saveState();
                        this.renderLayers();
                        this.setMode('select');
                        alert("Building Imported!");
                    }

                } catch (e) {
                    console.error(e);
                    document.body.style.cursor = 'default';
                    alert("Import failed. Check internet.");
                }
            }

            onDown(e) {
                const w = this.getWorldPos(e);
                if (e.button === 2) { this.isPanning = true; this.lastPan = { x: e.clientX, y: e.clientY }; return; }

                if (this.mode === 'place' && COMPONENTS[this.selectedToolId]?.type === 'panel') { this.arrayStart = w; return; }
                if (this.mode === 'select') {
                    if (this.selectedObjectId) {
                        const obj = this.objects.find(o => o.id === this.selectedObjectId);
                        if (obj) { const handle = this.getResizeHandle(obj, w); if (handle) { this.resizeHandle = handle; this.resizingObject = obj; return; } }
                    }
                    const obj = this.findObjectAt(w);
                    this.selectedObjectId = obj ? obj.id : null;
                    this.updateUI();
                    if (obj && obj.type !== 'grid') {
                        this.draggingObject = obj;
                        this.dragOffset = { x: w.x - obj.x, y: w.y - obj.y };
                        this.initialDragPos = { x: obj.x, y: obj.y };
                        this.draggingGroup = [];

                        // Handle Group Dragging
                        if (obj.groupId) {
                            this.objects.forEach(peer => {
                                if (peer.groupId === obj.groupId && peer.id !== obj.id) {
                                    this.draggingGroup.push({ obj: peer, offset: { x: w.x - peer.x, y: w.y - peer.y } });
                                }
                            });
                        }
                        // Handle Structure Parent-Child Dragging (if not already handled by group)
                        else if (obj.type === 'structure') {
                            this.objects.forEach(child => {
                                if (child.id !== obj.id && !child.groupId) { // Don't drag if child is part of another group
                                    const struct = this.getStructureBelow(child);
                                    if (struct && struct.id === obj.id) { this.draggingGroup.push({ obj: child, offset: { x: w.x - child.x, y: w.y - child.y } }); }
                                }
                            });
                        }
                    }
                }
                else if (this.mode === 'measure') this.measureStart = w;
                else if (this.mode === 'draw_rect') this.currentRectStart = w;
                else if (this.mode === 'place') this.placeComponent(w);
                else if (this.mode === 'delete') this.deleteAt(w);
                else if (['wire_dc', 'wire_ac', 'earthing'].includes(this.mode)) {
                    const t = this.findObjectAt(w, true); if (t) this.wireStartObj = t;
                }
            }

            onMove(e) {
                const w = this.getWorldPos(e);
                this.hoverPos = w;
                if (this.isPanning) { this.offsetX += e.clientX - this.lastPan.x; this.offsetY += e.clientY - this.lastPan.y; this.lastPan = { x: e.clientX, y: e.clientY }; }
                if (this.resizeHandle && this.resizingObject) {
                    const o = this.resizingObject; const minSize = 0.5;
                    if (this.resizeHandle === 'br') { o.w = Math.max(minSize, w.x - o.x); o.h = Math.max(minSize, w.y - o.y); }
                    else if (this.resizeHandle === 'bl') { const oldR = o.x + o.w; o.x = Math.min(oldR - minSize, w.x); o.w = oldR - o.x; o.h = Math.max(minSize, w.y - o.y); }
                    else if (this.resizeHandle === 'tr') { const oldB = o.y + o.h; o.y = Math.min(oldB - minSize, w.y); o.h = oldB - o.y; o.w = Math.max(minSize, w.x - o.x); }
                    else if (this.resizeHandle === 'tl') { const oldR = o.x + o.w; const oldB = o.y + o.h; o.x = Math.min(oldR - minSize, w.x); o.w = oldR - o.x; o.y = Math.min(oldB - minSize, w.y); o.h = oldB - o.y; }
                    if (isNaN(o.x)) o.x = 0; if (isNaN(o.y)) o.y = 0; if (isNaN(o.w)) o.w = 1; if (isNaN(o.h)) o.h = 1;
                } else if (this.draggingObject) {
                    const prevX = this.draggingObject.x; const prevY = this.draggingObject.y;
                    this.draggingObject.x = w.x - this.dragOffset.x;
                    this.draggingObject.y = w.y - this.dragOffset.y;
                    this.updateObjectZ(this.draggingObject);
                    if (this.draggingGroup && this.draggingGroup.length > 0) {
                        this.draggingGroup.forEach(item => {
                            item.obj.x = w.x - item.offset.x;
                            item.obj.y = w.y - item.offset.y;
                            // Keep z relative to parent 
                            this.updateObjectZ(item.obj);
                        });
                    }
                    this.updateUI();
                }
            }

            onUp(e) {
                const w = this.getWorldPos(e);
                this.isPanning = false;
                if (this.draggingObject || this.resizingObject) {
                    this.renderLayers(); this.saveState();
                    this.draggingObject = null; this.resizingObject = null; this.resizeHandle = null; this.draggingGroup = null;
                }
                if (this.mode === 'draw_rect' && this.currentRectStart) {
                    const width = Math.abs(w.x - this.currentRectStart.x); const height = Math.abs(w.y - this.currentRectStart.y);
                    if (width > 0.5 && height > 0.5) {
                        const relative_h = parseFloat(document.getElementById('height-slider').value) || 3;
                        const x = Math.min(this.currentRectStart.x, w.x), y = Math.min(this.currentRectStart.y, w.y);
                        let color = COLORS.obstacle, label = 'Obstacle', type = 'structure';
                        if (this.drawType === 'tree') { color = COLORS.tree; label = 'Tree'; type = 'obstacle'; }
                        else if (this.drawType === 'building') { color = COLORS.building; label = 'Building'; }
                        else if (this.drawType === 'roof') { color = COLORS.roof; label = 'Roof'; }
                        else if (this.drawType === 'tinshed') { color = COLORS.tinshed; label = 'Shed'; }
                        const tempObj = { x, y, w: width, h: height, type };
                        const struct = this.getStructureBelow(tempObj);
                        const baseZ = struct ? struct.h_z : 0;
                        this.objects.push({ id: Math.random().toString(36).slice(2), type, subType: this.drawType, x, y, w: width, h: height, h_z: baseZ + relative_h, relative_h, label: `${label} (${relative_h}m)`, color });
                        this.saveState(); this.updateStats();
                    }
                    this.currentRectStart = null;
                }
                if (this.arrayStart && this.mode === 'place') {
                    const dist = Math.hypot(w.x - this.arrayStart.x, w.y - this.arrayStart.y);
                    if (dist < 0.2) {
                        // Single click detected - place one panel
                        this.arrayStart = null;
                        this.placeComponent(w);
                    } else {
                        // Drag detected - fill array
                        const def = COMPONENTS[this.selectedToolId];
                        if (def && def.type === 'panel') {
                            const startX = Math.min(this.arrayStart.x, w.x); const startY = Math.min(this.arrayStart.y, w.y); const endX = Math.max(this.arrayStart.x, w.x); const endY = Math.max(this.arrayStart.y, w.y);
                            const cx = (startX + endX) / 2, cy = (startY + endY) / 2;
                            const tempObj = { x: cx, y: cy, w: 0, h: 0 };
                            const structure = this.getStructureBelow(tempObj);
                            const baseZ = structure ? structure.h_z : 0;
                            const relative_h = 0.5;
                            const h_z = baseZ + relative_h;
                            for (let y = startY; y + def.h <= endY + 0.1; y += def.h + 0.05) {
                                for (let x = startX; x + def.w <= endX + 0.1; x += def.w + 0.05) {
                                    // Improved collision check: overlaps with ANY object
                                    const hit = this.objects.some(o => {
                                        if (structure && o.id === structure.id) return false; // Ignore the roof we are placing on
                                        return (x < o.x + o.w && x + def.w > o.x && y < o.y + o.h && y + def.h > o.y);
                                    });
                                    if (!hit) this.objects.push({ ...def, id: Math.random().toString(36).slice(2), x, y, h_z, relative_h });
                                }
                            }
                            this.saveState(); this.updateStats();
                        }
                        this.arrayStart = null;
                    }
                }
                if (this.wireStartObj) {
                    const t = this.findObjectAt(w, true);
                    if (t && t !== this.wireStartObj) {
                        let type = 'invalid';
                        if (this.mode === 'earthing') { if (t.subtype === 'earth' || this.wireStartObj.subtype === 'earth') type = 'earth'; }
                        else if (this.mode === 'wire_dc') { const validA = (this.wireStartObj.type === 'panel' || this.wireStartObj.type === 'inverter'); const validB = (t.type === 'panel' || t.type === 'inverter'); if (validA && validB) type = 'dc'; }
                        else if (this.mode === 'wire_ac') { const validAC = o => ['inverter', 'bos', 'grid', 'lt_panel', 'ht_panel', 'meter_net', 'meter_gross', 'load'].includes(o.type); if (validAC(this.wireStartObj) && validAC(t)) type = 'ac'; }
                        if (type !== 'invalid') { this.wires.push({ start: this.wireStartObj.id, end: t.id, type }); this.saveState(); this.updateStats(); }
                    }
                    this.wireStartObj = null;
                }
                if (this.mode === 'measure') this.measureStart = null;
            }

            deleteAt(pos, id = null) {
                const t = id ? this.objects.find(o => o.id === id) : this.findObjectAt(pos);
                if (t && t.type !== 'grid') {
                    this.objects = this.objects.filter(o => o.id !== t.id);
                    this.wires = this.wires.filter(w => w.start !== t.id && w.end !== t.id);
                    this.objects.forEach(o => this.updateObjectZ(o));
                    this.selectedObjectId = null;
                    this.saveState();
                    this.updateStats();
                }
            }
            findObjectAt(pos, preferComponent = false) { const sorted = [...this.objects].sort((a, b) => (a.h_z - b.h_z) || (this.objects.indexOf(a) - this.objects.indexOf(b))); for (let i = sorted.length - 1; i >= 0; i--) { const o = sorted[i]; if (pos.x >= o.x && pos.x <= o.x + o.w && pos.y >= o.y && pos.y <= o.y + o.h) { if (preferComponent && o.type === 'structure') continue; return o; } } if (preferComponent) { for (let i = sorted.length - 1; i >= 0; i--) { const o = sorted[i]; if (pos.x >= o.x && pos.x <= o.x + o.w && pos.y >= o.y && pos.y <= o.y + o.h) return o; } } return null; }
            placeComponent(pos) {
                if (this.arrayStart) return;
                const def = COMPONENTS[this.selectedToolId]; if (!def) return;
                let x = Math.round(pos.x * 10) / 10, y = Math.round(pos.y * 10) / 10;
                const snapDist = 0.5;
                for (let o of this.objects) { if (o.type === def.type) { if (Math.abs(x - (o.x + o.w + def.w / 2)) < snapDist && Math.abs(y - (o.y + o.h / 2)) < snapDist) { x = o.x + o.w + def.w / 2; y = o.y + o.h / 2; break; } if (Math.abs(y - (o.y + o.h + def.h / 2)) < snapDist && Math.abs(x - (o.x + o.w / 2)) < snapDist) { y = o.y + o.h + def.h / 2; x = o.x + o.w / 2; break; } if (Math.abs(x - (o.x + o.w / 2)) < 0.2 && Math.abs(y - (o.y + o.h + def.h / 2)) < snapDist) { x = o.x + o.w / 2; } } }
                const relative_h = 0.5;
                const tempObj = { x, y, w: def.w, h: def.h };
                const structure = this.getStructureBelow(tempObj);
                const baseZ = structure ? structure.h_z : 0;
                this.objects.push({ ...def, id: Math.random().toString(36).slice(2), x: x - def.w / 2, y: y - def.h / 2, h_z: baseZ + relative_h, relative_h });
                this.saveState(); this.updateStats();
            }
            updateStats() {
                let dc = 0; this.calculatedCost = 0;
                this.objects.forEach(o => {
                    if (o.type === 'panel') dc += o.watts;
                    if (o.cost) this.calculatedCost += o.cost;
                });
                this.calculatedCost += this.wires.length * 500;
                document.getElementById('stat-dc-cap').innerText = (dc / 1000).toFixed(2) + ' kWp';

                const override = document.getElementById('input-plant-cost').value;
                const displayCost = override ? parseInt(override) : this.calculatedCost;
                document.getElementById('stat-cost').innerText = '₹' + displayCost.toLocaleString();
                if (!override) document.getElementById('input-plant-cost').placeholder = '₹' + this.calculatedCost;
            }
            resetCost() { document.getElementById('input-plant-cost').value = ''; this.updateStats(); }

            runSimulation() {
                if (typeof Chart === 'undefined') { alert("Chart.js not loaded yet. Please check internet."); return; }

                const baseLoad = parseFloat(document.getElementById('input-load').value) || 500;
                const loadBoxes = this.objects.filter(o => o.type === 'load');
                const boxLoad = loadBoxes.reduce((sum, b) => sum + (b.units || 500), 0);
                const load = baseLoad + boxLoad;

                const rate = parseFloat(document.getElementById('input-rate').value) || 8.5;
                const systemCost = parseInt(document.getElementById('stat-cost').innerText.replace(/[^0-9]/g, '')) || 0;

                const panels = this.objects.filter(o => o.type === 'panel');
                const invs = this.objects.filter(o => o.type === 'inverter');
                const systemSizeKw = panels.reduce((sum, p) => sum + p.watts, 0) / 1000;

                if (systemSizeKw === 0) {
                    document.getElementById('eval-modal').classList.remove('hidden');
                    document.getElementById('eval-score-circle').innerText = "0%";
                    document.getElementById('eval-score-circle').className = "w-24 h-24 rounded-full border-8 border-gray-300 flex items-center justify-center text-3xl font-bold text-gray-400 mx-auto mb-2";
                    document.getElementById('eval-verdict').innerText = "No System Installed";
                    document.getElementById('eval-summary').innerText = "Please place solar panels to evaluate.";
                    document.getElementById('eval-dc-size').innerText = "0 kWp";
                    document.getElementById('eval-annual-gen').innerText = "0 MWh";
                    return;
                }

                let issues = [], good = [];
                const adj = {};
                this.wires.forEach(w => {
                    // Check if start or end is an OFF ACDB or LT Panel
                    const startObj = this.objects.find(o => o.id === w.start);
                    const endObj = this.objects.find(o => o.id === w.end);
                    if (startObj && (startObj.subtype === 'acdb' || startObj.subtype === 'lt_panel') && startObj.isOn === false) return;
                    if (endObj && (endObj.subtype === 'acdb' || endObj.subtype === 'lt_panel') && endObj.isOn === false) return;

                    if (!adj[w.start]) adj[w.start] = []; adj[w.start].push(w.end);
                    if (!adj[w.end]) adj[w.end] = []; adj[w.end].push(w.start);
                });
                let allPanelsConnected = true;
                panels.forEach(p => {
                    let q = [p.id], visited = new Set([p.id]), foundInv = false;
                    while (q.length) { const curr = q.shift(); const obj = this.objects.find(o => o.id === curr); if (obj && obj.type === 'inverter') { foundInv = true; break; } if (adj[curr]) { adj[curr].forEach(n => { if (!visited.has(n)) { visited.add(n); q.push(n); } }); } }
                    if (!foundInv) allPanelsConnected = false;
                });
                if (!allPanelsConnected) issues.push("Some panels not connected to Inverter"); else if (panels.length > 0) good.push("All panels connected to Inverter");
                let invToGrid = true;
                invs.forEach(inv => {
                    let q = [inv.id], visited = new Set([inv.id]), foundGrid = false;
                    while (q.length) { const curr = q.shift(); const obj = this.objects.find(o => o.id === curr); if (obj && (obj.type === 'grid' || obj.subtype?.includes('meter'))) { foundGrid = true; break; } if (adj[curr]) { adj[curr].forEach(n => { if (!visited.has(n)) { visited.add(n); q.push(n); } }); } }
                    if (!foundGrid) invToGrid = false;
                });
                if (invs.length > 0 && !invToGrid) issues.push("Inverter not connected to Meter/Grid"); else if (invs.length > 0) good.push("Inverter connected to Grid");
                // if (systemSizeKw === 0) issues.push("No Solar Panels Installed"); // This check is now handled by the early return

                // Check Load Connection
                if (loadBoxes.length > 0) {
                    let allLoadsConnected = true;
                    loadBoxes.forEach(l => {
                        let q = [l.id], visited = new Set([l.id]), foundSource = false;
                        while (q.length) { const curr = q.shift(); const obj = this.objects.find(o => o.id === curr); if (obj && (obj.type === 'grid' || obj.type === 'inverter')) { foundSource = true; break; } if (adj[curr]) { adj[curr].forEach(n => { if (!visited.has(n)) { visited.add(n); q.push(n); } }); } }
                        if (!foundSource) allLoadsConnected = false;
                    });
                    if (!allLoadsConnected) issues.push("Some Load Boxes not connected to Power Source");
                }

                const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                const seasonality = [0.8, 0.9, 1.1, 1.2, 1.25, 1.1, 1.0, 0.95, 0.95, 1.0, 0.9, 0.8];

                const tableBodyRef = document.getElementById('month-table-body') || document.getElementById('year-table-body'); // Fallback
                if (tableBodyRef) tableBodyRef.innerHTML = '';

                // Use new Yearly Shadow Analysis
                const shadowLossPct = this.calculateYearlyShadowLoss();
                const shadowLossFactor = 1 - shadowLossPct;

                // Check Commercial
                const isCommercial = document.getElementById('check-commercial').checked;

                let totalGen = 0;
                const monthlyGenData = [];
                const monthlyLossData = [];
                months.forEach((m, i) => {
                    const potentialGen = systemSizeKw * 4.5 * 30 * seasonality[i];
                    const gen = potentialGen * shadowLossFactor;
                    const loss = potentialGen - gen;
                    monthlyLossData.push(loss);

                    totalGen += gen; monthlyGenData.push(gen);
                    const net = gen - load;
                    // Net Metering: Saving = Self Consumed * Rate + Export * Rate (assuming 1:1 for simplicity here)
                    // Or if Export < Import rate, logic changes. Here assuming Flat Rate.
                    const netSaving = (gen >= load) ? (load * rate + (gen - load) * rate) : (gen * rate);
                    // Gross Metering: Income = Gen * Rate
                    const grossIncome = gen * rate;

                    if (tableBodyRef) {
                        const row = `<tr>
                            <td class="px-3 py-2 font-bold text-gray-600">${m}</td>
                            <td class="px-3 py-2 text-right text-green-600">${gen.toFixed(0)}</td>
                            <td class="px-3 py-2 text-right text-red-600">${load.toFixed(0)}</td>
                            <td class="px-3 py-2 text-right ${net >= 0 ? 'text-blue-600' : 'text-orange-600'}">${net.toFixed(0)}</td>
                            <td class="px-3 py-2 text-right text-gray-800 font-mono">₹${netSaving.toFixed(0)}</td>
                            <td class="px-3 py-2 text-right text-green-800 font-mono font-bold">₹${grossIncome.toFixed(0)}</td>
                        </tr>`;
                        tableBodyRef.innerHTML += row;
                    }
                });

                const yearTableBody = document.getElementById('year-table-body');
                if (yearTableBody) {
                    yearTableBody.innerHTML = '';
                    let cumulativeSavings = 0;
                    let roiReached = false;
                    for (let y = 1; y <= 25; y++) {
                        const degradation = Math.pow(0.995, y - 1);
                        const yearGen = totalGen * degradation;
                        let yearSavings = yearGen * rate;

                        // Accelerated Depreciation (AD) Benefit in Year 1
                        if (y === 1 && isCommercial) {
                            // Assuming 40% AD, 30% Tax Bracket -> Benefit = Cost * 0.40 * 0.30
                            const adBenefit = systemCost * 0.40 * 0.30;
                            yearSavings += adBenefit;
                        }

                        cumulativeSavings += yearSavings;
                        const roiStatus = (!roiReached && cumulativeSavings >= systemCost) ? `<span class="text-green-600 font-bold">Break Even</span>` : (cumulativeSavings >= systemCost ? 'Profitable' : 'Recovering');
                        if (!roiReached && cumulativeSavings >= systemCost) roiReached = true;

                        const row = `<tr>
                            <td class="px-3 py-2 font-bold text-gray-600">Year ${y}</td>
                            <td class="px-3 py-2 text-right text-blue-600">${(yearGen / 1000).toFixed(1)} MWh</td>
                            <td class="px-3 py-2 text-right text-green-600">₹${yearSavings.toFixed(0)}</td>
                            <td class="px-3 py-2 text-right font-mono">₹${cumulativeSavings.toFixed(0)}</td>
                            <td class="px-3 py-2 text-right text-xs">${roiStatus}</td>
                        </tr>`;
                        yearTableBody.innerHTML += row;
                    }
                }

                document.getElementById('eval-modal').classList.remove('hidden');
                // Update Modal
                // const checklistScore = Math.round((good.length / (good.length + issues.length || 1)) * 100);
                // const efficiencyScore = Math.round(checklistScore * (1 - shadowLossPct));

                // document.getElementById('eval-score').innerText = efficiencyScore + '%';
                // document.getElementById('eval-title').innerText = issues.length === 0 ? "System Optimized" : "Attention Needed";
                // document.getElementById('eval-desc').innerText = `Checklist: ${checklistScore}%. Efficiency: ${(100 - shadowLossPct * 100).toFixed(1)}%.`;
                // document.getElementById('eval-size').innerText = systemSizeKw.toFixed(2) + " kWp";
                // document.getElementById('eval-gen').innerText = (totalGen / 1000).toFixed(1) + " MWh";
                // document.getElementById('eval-list').innerHTML = [...issues, ...good].map(t => `<li class="flex items-center gap-2 ${issues.includes(t) ? 'text-red-600' : 'text-green-600'}"><i class="fa-solid ${issues.includes(t) ? 'fa-xmark' : 'fa-check'}"></i> ${t}</li>`).join('');

                document.getElementById('eval-dc-size').innerText = systemSizeKw.toFixed(1) + " kWp";
                document.getElementById('eval-annual-gen').innerText = (totalGen / 1000).toFixed(1) + " MWh";

                const checklistScore = Math.max(0, 100 - (issues.length * 20));
                const finalScore = Math.round(checklistScore * shadowLossFactor);

                const scoreEl = document.getElementById('eval-score-circle');
                scoreEl.innerText = finalScore + "%";
                if (finalScore > 80) { scoreEl.className = "w-24 h-24 rounded-full border-8 border-green-500 flex items-center justify-center text-3xl font-bold text-green-600 mx-auto mb-2"; document.getElementById('eval-verdict').innerText = "System Optimized"; document.getElementById('eval-verdict').className = "text-lg font-bold mb-1 text-green-600"; }
                else if (finalScore > 50) { scoreEl.className = "w-24 h-24 rounded-full border-8 border-yellow-500 flex items-center justify-center text-3xl font-bold text-yellow-600 mx-auto mb-2"; document.getElementById('eval-verdict').innerText = "Needs Improvement"; document.getElementById('eval-verdict').className = "text-lg font-bold mb-1 text-yellow-600"; }
                else { scoreEl.className = "w-24 h-24 rounded-full border-8 border-red-500 flex items-center justify-center text-3xl font-bold text-red-600 mx-auto mb-2"; document.getElementById('eval-verdict').innerText = "Critical Issues"; document.getElementById('eval-verdict').className = "text-lg font-bold mb-1 text-red-600"; }

                const list = document.getElementById('eval-list');
                list.innerHTML = '';
                issues.forEach(i => list.innerHTML += `<li class="text-red-600"><i class="fa-solid fa-circle-xmark mr-2"></i>${i}</li>`);
                good.forEach(i => list.innerHTML += `<li class="text-green-600"><i class="fa-solid fa-check-circle mr-2"></i>${i}</li>`);
                list.innerHTML += `<li class="text-blue-600"><i class="fa-solid fa-cloud-sun mr-2"></i>Shadow Loss: ${(shadowLossPct * 100).toFixed(1)}%</li>`;

                // Charts
                if (window.genChartInst) window.genChartInst.destroy();
                if (window.roiChartInst) window.roiChartInst.destroy();
                if (window.lossChartInst) window.lossChartInst.destroy();

                const ctxGen = document.getElementById('genChart').getContext('2d');
                window.genChartInst = new Chart(ctxGen, {
                    type: 'bar',
                    data: { labels: months, datasets: [{ label: 'Generation (kWh)', data: monthlyGenData, backgroundColor: '#22c55e' }] },
                    options: { responsive: true, maintainAspectRatio: false, plugins: { title: { display: true, text: 'Monthly Generation' } } }
                });

                const ctxRoi = document.getElementById('roiChart').getContext('2d');
                window.roiChartInst = new Chart(ctxRoi, {
                    type: 'line',
                    data: { labels: Array.from({ length: 25 }, (_, i) => `Y${i + 1}`), datasets: [{ label: 'Cumulative Savings (₹)', data: Array.from({ length: 25 }, (_, i) => { const deg = Math.pow(0.995, i); return totalGen * deg * rate * (i + 1); }), borderColor: '#3b82f6', fill: true }] }, // Simplified for chart
                    options: { responsive: true, maintainAspectRatio: false, plugins: { title: { display: true, text: 'ROI Projection' } } }
                });

                const ctxLoss = document.getElementById('lossChart').getContext('2d');
                window.lossChartInst = new Chart(ctxLoss, {
                    type: 'bar',
                    data: {
                        labels: months,
                        datasets: [
                            { label: 'Actual Generation', data: monthlyGenData, backgroundColor: '#22c55e' },
                            { label: 'Loss due to Shadow', data: monthlyLossData, backgroundColor: '#ef4444' }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: { x: { stacked: true }, y: { stacked: true } },
                        plugins: { title: { display: true, text: 'Generation vs Shadow Loss' } }
                    }
                });
            }

            downloadReport() {
                const load = parseFloat(document.getElementById('input-load').value) || 500;
                const rate = parseFloat(document.getElementById('input-rate').value) || 8.5;
                const systemCost = parseInt(document.getElementById('stat-cost').innerText.replace(/[^0-9]/g, '')) || 0;
                const panels = this.objects.filter(o => o.type === 'panel');
                const systemSizeKw = panels.reduce((sum, p) => sum + p.watts, 0) / 1000;

                let csv = "Solar Architect - Performance Report\n";
                csv += `System Size,${systemSizeKw.toFixed(2)} kWp\n`;
                csv += `Estimated Cost,INR ${systemCost}\n`;
                csv += `Grid Rate,INR ${rate}/unit\n`;
                csv += `Monthly Load,${load} Units\n\n`;

                csv += "Year,Month,Generation (Units),Consumption (Units),Net Export (Units),Bill Saving (INR),Cumulative Saving (INR)\n";

                const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                const seasonality = [0.8, 0.9, 1.1, 1.2, 1.25, 1.1, 1.0, 0.95, 0.95, 1.0, 0.9, 0.8];
                let cumSavings = -systemCost;

                for (let y = 1; y <= 25; y++) {
                    const degradation = Math.pow(0.995, y - 1);
                    months.forEach((m, i) => {
                        const gen = systemSizeKw * 4.5 * 30 * seasonality[i] * degradation;
                        const net = gen - load;
                        // Simple Net Metering Logic: If Gen > Load, save full bill + export credit. If Gen < Load, save Gen * Rate.
                        // Assuming flat rate for import/export for simplicity
                        const saving = (gen >= load) ? (load * rate + (gen - load) * rate) : (gen * rate);
                        cumSavings += saving;

                        csv += `${y},${m},${gen.toFixed(2)},${load},${net.toFixed(2)},${saving.toFixed(2)},${cumSavings.toFixed(2)}\n`;
                    });
                }

                const blob = new Blob([csv], { type: 'text/csv' });
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.setAttribute('hidden', '');
                a.setAttribute('href', url);
                a.setAttribute('download', 'solar_report_25yr.csv');
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
            }

            loop() { if (!this.isRunning) return; this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height); this.ctx.fillStyle = COLORS.bg; this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height); if (this.showGrid) this.drawGrid(); this.drawRulers(); this.drawShadows(); this.objects.sort((a, b) => (a.h_z - b.h_z) || (a.y - b.y)).forEach(o => this.drawObject(o)); this.drawShadowsOnObjects(); this.drawWires(); this.drawOverlays(); this.drawSunPath(); requestAnimationFrame(() => this.loop()); }
            drawRulers() { this.ctx.fillStyle = '#374151'; this.ctx.fillRect(0, 0, this.canvas.width, 20); this.ctx.fillRect(0, 0, 20, this.canvas.height); this.ctx.strokeStyle = '#6b7280'; this.ctx.fillStyle = '#9ca3af'; this.ctx.font = '10px monospace'; this.ctx.textAlign = 'center'; const startX = Math.floor(-this.offsetX / this.scale); const endX = Math.ceil((this.canvas.width - this.offsetX) / this.scale); this.ctx.beginPath(); for (let i = startX; i <= endX; i++) { const x = i * this.scale + this.offsetX; if (i % 5 === 0) { this.ctx.moveTo(x, 0); this.ctx.lineTo(x, 15); this.ctx.fillText(i, x, 12); } else { this.ctx.moveTo(x, 15); this.ctx.lineTo(x, 20); } } this.ctx.stroke(); const startY = Math.floor(-this.offsetY / this.scale); const endY = Math.ceil((this.canvas.height - this.offsetY) / this.scale); this.ctx.beginPath(); this.ctx.textAlign = 'left'; for (let i = startY; i <= endY; i++) { const y = i * this.scale + this.offsetY; if (i % 5 === 0) { this.ctx.moveTo(0, y); this.ctx.lineTo(15, y); this.ctx.save(); this.ctx.translate(2, y - 2); this.ctx.rotate(-Math.PI / 2); this.ctx.fillText(i, 0, 10); this.ctx.restore(); } else { this.ctx.moveTo(15, y); this.ctx.lineTo(20, y); } } this.ctx.stroke(); }
            drawGrid() {
                // Draw Map Overlay if available
                if (this.mapImage) {
                    const cx = this.canvas.width / 2;
                    const cy = this.canvas.height / 2;

                    // Calculate scale factor
                    // mapMetersPerPixel is real world meters per pixel of the image.
                    // this.scale is pixels per meter on our canvas.
                    // So 1 meter = this.scale pixels.
                    // Image 1 pixel = mapMetersPerPixel meters = mapMetersPerPixel * this.scale canvas pixels.
                    const imgScale = this.mapMetersPerPixel * this.scale;

                    const w = this.mapImage.width * imgScale;
                    const h = this.mapImage.height * imgScale;

                    // Draw centered at 0,0 world coords
                    // World 0,0 is at screen (this.offsetX, this.offsetY)
                    const x = this.offsetX - w / 2;
                    const y = this.offsetY - h / 2;

                    this.ctx.drawImage(this.mapImage, x, y, w, h);

                    // Dim the map slightly
                    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                    this.ctx.fillRect(x, y, w, h);
                }

                this.ctx.strokeStyle = COLORS.grid;
                this.ctx.lineWidth = 1;
                this.ctx.beginPath();
                for (let x = this.offsetX % this.scale; x < this.canvas.width; x += this.scale) {
                    this.ctx.moveTo(x, 0);
                    this.ctx.lineTo(x, this.canvas.height);
                }
                for (let y = this.offsetY % this.scale; y < this.canvas.height; y += this.scale) {
                    this.ctx.moveTo(0, y);
                    this.ctx.lineTo(this.canvas.width, y);
                }
                this.ctx.stroke();
            }
            drawSunPath() { const cx = this.canvas.width / 2; const cy = this.canvas.height / 2; const r = Math.min(this.canvas.width, this.canvas.height) * 0.4; this.ctx.strokeStyle = 'rgba(234, 179, 8, 0.1)'; this.ctx.lineWidth = 2; this.ctx.setLineDash([10, 10]); this.ctx.beginPath(); this.ctx.arc(cx, cy, r, 0, Math.PI, false); this.ctx.stroke(); this.ctx.setLineDash([]); const angle = ((this.sunTime - 6) / 12) * Math.PI; const sunX = cx + r * Math.cos(angle); const sunY = cy + r * Math.sin(angle); this.ctx.fillStyle = '#fbbf24'; this.ctx.shadowColor = '#fbbf24'; this.ctx.shadowBlur = 20; this.ctx.beginPath(); this.ctx.arc(sunX, sunY, 8, 0, Math.PI * 2); this.ctx.fill(); this.ctx.shadowBlur = 0; }
            getShadowVector() { const angle = ((this.sunTime - 6) / 12) * Math.PI + (this.orientation * Math.PI / 180); const elevation = Math.sin(((this.sunTime - 6) / 12) * Math.PI); if (elevation < 0.1) return null; const len = Math.min(3.0, (1 / Math.max(0.15, elevation)) * 0.7); return { x: -Math.cos(angle) * len, y: -Math.sin(angle) * len }; }

            drawShadowPoly(x, y, w, h, dx, dy) {
                if (Math.abs(dx) < 0.01 && Math.abs(dy) < 0.01) return;
                const s = this.worldToScreen(x, y);
                const ws = w * this.scale, hs = h * this.scale;
                const offX = dx * this.scale, offY = dy * this.scale;
                if (isNaN(s.x) || isNaN(offX)) return;
                this.ctx.beginPath();
                const c1 = { x: s.x, y: s.y }; const c2 = { x: s.x + ws, y: s.y }; const c3 = { x: s.x + ws, y: s.y + hs }; const c4 = { x: s.x, y: s.y + hs };
                const p1 = { x: c1.x + offX, y: c1.y + offY }; const p2 = { x: c2.x + offX, y: c2.y + offY }; const p3 = { x: c3.x + offX, y: c3.y + offY }; const p4 = { x: c4.x + offX, y: c4.y + offY };
                if (dx >= 0 && dy >= 0) { this.ctx.moveTo(c4.x, c4.y); this.ctx.lineTo(c1.x, c1.y); this.ctx.lineTo(c2.x, c2.y); this.ctx.lineTo(p2.x, p2.y); this.ctx.lineTo(p3.x, p3.y); this.ctx.lineTo(p4.x, p4.y); }
                else if (dx < 0 && dy >= 0) { this.ctx.moveTo(c1.x, c1.y); this.ctx.lineTo(c2.x, c2.y); this.ctx.lineTo(c3.x, c3.y); this.ctx.lineTo(p3.x, p3.y); this.ctx.lineTo(p4.x, p4.y); this.ctx.lineTo(p1.x, p1.y); }
                else if (dx < 0 && dy < 0) { this.ctx.moveTo(c2.x, c2.y); this.ctx.lineTo(c3.x, c3.y); this.ctx.lineTo(c4.x, c4.y); this.ctx.lineTo(p4.x, p4.y); this.ctx.lineTo(p1.x, p1.y); this.ctx.lineTo(p2.x, p2.y); }
                else { this.ctx.moveTo(c3.x, c3.y); this.ctx.lineTo(c4.x, c4.y); this.ctx.lineTo(c1.x, c1.y); this.ctx.lineTo(p1.x, p1.y); this.ctx.lineTo(p2.x, p2.y); this.ctx.lineTo(p3.x, p3.y); }
                this.ctx.closePath();
                this.ctx.fill();
            }

            calculateShadowLoss() {
                const v = this.getShadowVector();
                if (!v) return 0;

                let totalPanelArea = 0;
                let totalShadowArea = 0;

                const panels = this.objects.filter(o => o.type === 'panel');
                if (panels.length === 0) return 0;

                panels.forEach(p => {
                    totalPanelArea += p.w * p.h;
                    let points = 0;
                    const samples = 10; // Monte Carlo samples per panel
                    for (let i = 0; i < samples; i++) {
                        const px = p.x + Math.random() * p.w;
                        const py = p.y + Math.random() * p.h;

                        let inShadow = false;
                        for (let o of this.objects) {
                            if (o.id === p.id) continue;
                            if (o.h_z <= p.h_z) continue;

                            const dh = o.h_z - p.h_z;
                            const dx = v.x * dh;
                            const dy = v.y * dh;

                            const sx = o.x + dx;
                            const sy = o.y + dy;

                            if (px >= sx && px <= sx + o.w && py >= sy && py <= sy + o.h) {
                                inShadow = true;
                                break;
                            }
                        }
                        if (inShadow) points++;
                    }
                    totalShadowArea += (points / samples) * (p.w * p.h);
                });

                return totalPanelArea > 0 ? (totalShadowArea / totalPanelArea) : 0;
            }

            drawShadows() {
                const v = this.getShadowVector(); if (!v) return; this.ctx.fillStyle = COLORS.shadow;
                this.objects.forEach(o => {
                    if (o.h_z > 0) {
                        this.drawShadowPoly(o.x, o.y, o.w, o.h, v.x * o.h_z, v.y * o.h_z);
                    }
                });
            }

            drawShadowsOnObjects() { const v = this.getShadowVector(); if (!v) return; for (let i = 0; i < this.objects.length; i++) { const caster = this.objects[i]; if (caster.h_z <= 0) continue; for (let j = 0; j < this.objects.length; j++) { if (i === j) continue; const receiver = this.objects[j]; if (receiver.h_z >= caster.h_z) continue; const deltaH = caster.h_z - receiver.h_z; const vecX = v.x * deltaH; const vecY = v.y * deltaH; this.ctx.save(); this.ctx.beginPath(); const s = this.worldToScreen(receiver.x, receiver.y); this.ctx.rect(s.x, s.y, receiver.w * this.scale, receiver.h * this.scale); this.ctx.clip(); this.ctx.fillStyle = 'rgba(0,0,0,0.3)'; this.drawShadowPoly(caster.x, caster.y, caster.w, caster.h, vecX, vecY); this.ctx.restore(); } } }

            drawObject(o) {
                const s = this.worldToScreen(o.x, o.y); const w = o.w * this.scale, h = o.h * this.scale;
                if (isNaN(s.x) || isNaN(w)) return;
                this.ctx.fillStyle = o.color || '#fff';
                if (o.subType === 'tree') this.ctx.fillStyle = COLORS.tree;
                this.ctx.fillRect(s.x, s.y, w, h);
                if (o.subType === 'tinshed') { this.ctx.strokeStyle = 'rgba(255,255,255,0.2)'; this.ctx.beginPath(); for (let i = 0; i < w; i += 10) { this.ctx.moveTo(s.x + i, s.y); this.ctx.lineTo(s.x + i, s.y + h); } this.ctx.stroke(); }
                this.ctx.strokeStyle = '#000';
                this.ctx.lineWidth = this.selectedObjectId === o.id ? 2 : 1;
                if (this.selectedObjectId === o.id) this.ctx.strokeStyle = '#3b82f6';
                this.ctx.strokeRect(s.x, s.y, w, h);
                if (o.label || o.type === 'panel') {
                    this.ctx.fillStyle = 'white'; this.ctx.font = '10px Arial';
                    if (o.type === 'panel') { this.ctx.strokeStyle = 'rgba(255,255,255,0.3)'; this.ctx.beginPath(); this.ctx.moveTo(s.x + w / 2, s.y); this.ctx.lineTo(s.x + w / 2, s.y + h); this.ctx.stroke(); }
                    else if (o.label) {
                        this.ctx.shadowColor = "black"; this.ctx.shadowBlur = 2; this.ctx.fillText(o.label, s.x, s.y - 5); this.ctx.shadowBlur = 0;
                    }
                    // Draw Switch Status for ACDB and LT Panel
                    if (o.subtype === 'acdb' || o.subtype === 'lt_panel') {
                        this.ctx.beginPath();
                        this.ctx.arc(s.x + w - 5, s.y + 5, 3, 0, Math.PI * 2);
                        this.ctx.fillStyle = o.isOn !== false ? '#22c55e' : '#ef4444';
                        this.ctx.fill();
                    }
                    // Draw Load Icon
                    if (o.type === 'load') {
                        this.ctx.fillStyle = 'white';
                        this.ctx.font = '12px FontAwesome';
                        this.ctx.fillText('\uf0eb', s.x + w / 2 - 4, s.y + h / 2 + 4); // Lightbulb
                    }
                }
            }

            drawWires() {
                this.wires.forEach(l => {
                    const a = this.objects.find(o => o.id === l.start), b = this.objects.find(o => o.id === l.end);
                    if (!a || !b) return;
                    const s1 = this.worldToScreen(a.x + a.w / 2, a.y + a.h / 2), s2 = this.worldToScreen(b.x + b.w / 2, b.y + b.h / 2);
                    this.ctx.strokeStyle = COLORS['wire_' + l.type] || 'white'; this.ctx.lineWidth = 2;
                    this.ctx.beginPath();
                    this.ctx.moveTo(s1.x, s1.y);
                    if (this.cableMode === 'ortho') { this.ctx.lineTo(s2.x, s1.y); }
                    this.ctx.lineTo(s2.x, s2.y);
                    this.ctx.stroke();
                });
            }

            drawOverlays() {
                if (this.mode === 'draw_rect' && this.currentRectStart) { const s = this.worldToScreen(this.currentRectStart.x, this.currentRectStart.y); const c = this.worldToScreen(this.hoverPos.x, this.hoverPos.y); this.ctx.strokeStyle = '#fbbf24'; this.ctx.setLineDash([5, 5]); this.ctx.strokeRect(s.x, s.y, c.x - s.x, c.y - s.y); this.ctx.setLineDash([]); const w = Math.abs(this.hoverPos.x - this.currentRectStart.x).toFixed(1), h = Math.abs(this.hoverPos.y - this.currentRectStart.y).toFixed(1); this.ctx.fillStyle = '#fbbf24'; this.ctx.fillText(`${w}m x ${h}m`, s.x, s.y - 5); }
                if (this.arrayStart && this.mode === 'place') { const s = this.worldToScreen(this.arrayStart.x, this.arrayStart.y); const c = this.worldToScreen(this.hoverPos.x, this.hoverPos.y); this.ctx.strokeStyle = '#3b82f6'; this.ctx.lineWidth = 2; this.ctx.setLineDash([5, 5]); this.ctx.strokeRect(s.x, s.y, c.x - s.x, c.y - s.y); this.ctx.setLineDash([]); const def = COMPONENTS[this.selectedToolId]; const startX = Math.min(this.arrayStart.x, this.hoverPos.x); const startY = Math.min(this.arrayStart.y, this.hoverPos.y); const endX = Math.max(this.arrayStart.x, this.hoverPos.x); const endY = Math.max(this.arrayStart.y, this.hoverPos.y); this.ctx.globalAlpha = 0.3; this.ctx.fillStyle = def.color; for (let y = startY; y + def.h <= endY + 0.1; y += def.h + 0.05) { for (let x = startX; x + def.w <= endX + 0.1; x += def.w + 0.05) { const sc = this.worldToScreen(x, y); this.ctx.fillRect(sc.x, sc.y, def.w * this.scale, def.h * this.scale); } } this.ctx.globalAlpha = 1; }
                else if (this.mode === 'place' && this.selectedToolId && !this.arrayStart) { const def = COMPONENTS[this.selectedToolId]; const s = this.worldToScreen(this.hoverPos.x, this.hoverPos.y); this.ctx.globalAlpha = 0.5; this.ctx.fillStyle = def.color; this.ctx.fillRect(s.x - def.w * this.scale / 2, s.y - def.h * this.scale / 2, def.w * this.scale, def.h * this.scale); this.ctx.globalAlpha = 1; }

                if (this.selectedObjectId) {
                    const o = this.objects.find(x => x.id === this.selectedObjectId);
                    if (o) {
                        const s = this.worldToScreen(o.x, o.y); const w = o.w * this.scale, h = o.h * this.scale;
                        this.ctx.fillStyle = '#3b82f6'; const hs = 6;
                        this.ctx.fillRect(s.x - hs / 2, s.y - hs / 2, hs, hs); this.ctx.fillRect(s.x + w - hs / 2, s.y - hs / 2, hs, hs); this.ctx.fillRect(s.x - hs / 2, s.y + h - hs / 2, hs, hs); this.ctx.fillRect(s.x + w - hs / 2, s.y + h - hs / 2, hs, hs);
                        this.ctx.font = '10px sans-serif'; this.ctx.fillStyle = '#3b82f6'; this.ctx.textAlign = 'center'; this.ctx.fillText(`${o.w.toFixed(1)}m`, s.x + w / 2, s.y - 10); this.ctx.save(); this.ctx.translate(s.x - 10, s.y + h / 2); this.ctx.rotate(-Math.PI / 2); this.ctx.fillText(`${o.h.toFixed(1)}m`, 0, 0); this.ctx.restore();
                    }
                }
                if (this.wireStartObj) { const a = this.objects.find(o => o.id === this.wireStartObj.id); if (a) { const s = this.worldToScreen(a.x + a.w / 2, a.y + a.h / 2); const e = this.worldToScreen(this.hoverPos.x, this.hoverPos.y); this.ctx.beginPath(); this.ctx.moveTo(s.x, s.y); this.ctx.lineTo(e.x, e.y); this.ctx.strokeStyle = '#fbbf24'; this.ctx.lineWidth = 2; this.ctx.setLineDash([5, 5]); this.ctx.stroke(); this.ctx.setLineDash([]); } }
            }
            worldToScreen(wx, wy) { return { x: wx * this.scale + this.offsetX, y: wy * this.scale + this.offsetY }; }
        }

        const app = new GameApp();
        window.currentSolarApp = app;
    </script>
</body>

</html>